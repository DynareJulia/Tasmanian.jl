var documenterSearchIndex = {"docs":
[{"location":"#API","page":"API","title":"API","text":"","category":"section"},{"location":"","page":"API","title":"API","text":"Modules = [Tasmanian]\nOrder   = [:function, :type]","category":"page"},{"location":"#Base.read-Tuple{TasmanianSG, Any}","page":"API","title":"Base.read","text":"read(tsg::TasmanianSG, filename)\n\nreads the tsg grid from a file discards any existing grid held by tsg\n\ntsg: an existing grid filename: string indicating a grid file where a grid was             already written using write from Julia or any other             Tasmanian interface\n\noutput: Bool         true: the read was successful         false: the read failed,                  check for an error message\n\n\n\n\n\n","category":"method"},{"location":"#Base.write-Tuple{TasmanianSG, Any}","page":"API","title":"Base.write","text":"write(tsg::TasmanianSG, filename; binary::Bool=true)\n\nwrites the tsg grid to a file\n\ntsg: an existing grid filename: string indicating a grid file where a grid will be written binary: Bool     true: write to a binary file     false: write to an ASCII file\n\n\n\n\n\n","category":"method"},{"location":"#Tasmanian.clearConformalTransform-Tuple{TasmanianSG}","page":"API","title":"Tasmanian.clearConformalTransform","text":"clearConformalTransform(tsg::TasmanianSG)\n\nresets the conformal domain transform loaded values will be kept, however, the values now correspond to canonical points and may be invalid for your application\n\n\n\n\n\n","category":"method"},{"location":"#Tasmanian.clearDomainTransform-Tuple{TasmanianSG}","page":"API","title":"Tasmanian.clearDomainTransform","text":"clearDomainTransform(tsg::TasmanianSG)\n\nresets the domain to canonical loaded values will be kept, however, the values now correspond to canonical points and may be invalid for your application\n\n\n\n\n\n","category":"method"},{"location":"#Tasmanian.clearLevelLimits-Tuple{TasmanianSG}","page":"API","title":"Tasmanian.clearLevelLimits","text":"clearLevelLimits(tsg::TasmanianSG)\n\nclears the limits set by the last make***Grid or refine command if no limits are set, this has no effect\n\n\n\n\n\n","category":"method"},{"location":"#Tasmanian.clearRefinement-Tuple{TasmanianSG}","page":"API","title":"Tasmanian.clearRefinement","text":"clearRefinement(tsg::TasmanianSG)\n\nclear the last call to set***Refinement, only works if called before the points are loaded, i.e., before loadNeededPoints()\n\nif getNumNeeded() == 0, this call will have no effect\n\n\n\n\n\n","category":"method"},{"location":"#Tasmanian.copyGrid","page":"API","title":"Tasmanian.copyGrid","text":"copyGrid(tsg::TasmanianSG, outputs_begin = 0, outputs_end = -1)\n\naccepts an instance of TasmanianSparseGrid class and creates a hard copy of the class and all included data original class is not modified\n\ntsg: instance of TasmanianSG      the source for the copy\n\noutputs_begin: integer indicating the first output to copy\n\noutputsend: integer one bigger than the last output to copy             if set to -1, all outputs from outputsbegin to             the end will be copied\n\nExamples:\n\ncopyGrid(other, 0, -1) # copy all outputs (default) copyGrid(other, 0, getNumOutputs(other)) # also copy all copyGrid(other, 0, 3) # copy outputs 0, 1, and 2 copyGrid(other, 1, 4) # copy outputs 1, 2, and 3\n\n\n\n\n\n","category":"function"},{"location":"#Tasmanian.differentiate!-Tuple{VecOrMat{Float64}, TasmanianSG, Vector{Float64}}","page":"API","title":"Tasmanian.differentiate!","text":"differentiate!(jacobian::VecOrMat{Float64}, tsg::TasmanianSG, x::AbstractVector{Float64})\n\nreturns the derivative (Jacobian or gradient vector) of the interpolant\n\njacobian:  a vector or a matrix            with dimensions dimensions X outputs            each row corresponds to the value of the interpolant            for one columns of vals tsg:  an instance of TasmanianSG x: a vector with length dimensions which is the evaluation point\n\n\n\n\n\n","category":"method"},{"location":"#Tasmanian.differentiate-Tuple{TasmanianSG, Vector{Float64}}","page":"API","title":"Tasmanian.differentiate","text":"differentiate(tsg::TasmanianSG, x::Vector{Float64})\n\nreturns the derivative (Jacobian or gradient vector) of the interpolant as a vector or a matrix with dimensions dimensions X outputs each row corresponds to the value of the interpolant\n\ntsg:  an instance of TasmanianSG x: a vector with length iDimensions which is the evaluation point\n\n\n\n\n\n","category":"method"},{"location":"#Tasmanian.enableAcceleration-Tuple{TasmanianSG, Any}","page":"API","title":"Tasmanian.enableAcceleration","text":"enableAcceleration(tsg::TasmanianSG, acceleration_type, GPUID = 0)\n\nEnables the use of accelerated backend libraries and extensions, such as BLAS and CUDA. Each acceleration type requires corresponding CMake compile options, otherwise the backend will fallback to the closest available options.\n\nsAccelerationType: string\n\n'none'       core fallback mode, relies on sequential implementation       if compiled with TasmanianENABLEOPENMP this will use       simple \"omp parallel for\" to take advantage of multiple cpu cores\n\n'cpu-blas'       uses BLAS level 2 and 3 functions for acceleration of batch       evaluations       requires TasmanianENABLEBLAS=ON       this is the default mode, if available\n\n'gpu-default'       uses CUDA kernels, cuBlas, cuSparse and MAGMA libraries for       accelerated matrix operations, e.g., cublasDgemm       refer to TasGrid::TypeAcceleration for more details\n\n'gpu_cublas'       uses the Nvidia cuBlas and cuSparse libraries\n\n'gpu-cuda'       uses custom CUDA kernels in addition to the accelerated       linear algebra libraries\n\n'gpu-magma'       uses the custom CUDA kernels and the MAGMA library in place       of the default Nvidia libraries\n\nGPUID: integer       indicates the GPU device to use, if set to None then device       zero will be used first or the device set with setGPUID()\n\n\n\n\n\n","category":"method"},{"location":"#Tasmanian.estimateAnisotropicCoefficients-Tuple{TasmanianSG, Any, Any}","page":"API","title":"Tasmanian.estimateAnisotropicCoefficients","text":"estimateAnisotropicCoefficients(tsg::TasmanianSG, type, output)\n\nreturns the estimate of the anisotropic coefficients from the current set of loaded points see the manual\n\ntype: string identifying the estimate to use (see the Manual)        recommended: 'iptotal'   'ipcurved'\n\noutput: int (indicates the output to use)      selects which output to use for refinement      sequence grids accept -1 to indicate all outputs\n\nreturns vector of length getNumDimensions() or 2*getNumDimensions()         the first set of getNumDimensions() entries correspond to the xi coefficients          the second set of getNumDimensions() entries correspond to the eta coefficients\n\n\n\n\n\n","category":"method"},{"location":"#Tasmanian.evaluate-Tuple{TasmanianSG, Any}","page":"API","title":"Tasmanian.evaluate","text":"evaluate(tsg::TasmanianSG, x)\n\nevaluates the intepolant at a single points of interest and returns the result This is the accelerated version using the selected acceleration type, but it is potentially not thread safe\n\nthis should be called after the grid has been created and after values have been loaded\n\nx: a vector with length getNumDimensions()    the entries indicate the points for evaluating the weights\n\noutput: returns vector of length getNumOutputs()         the values of the interpolant at fX\n\n\n\n\n\n","category":"method"},{"location":"#Tasmanian.evaluateBatch!-Tuple{AbstractVecOrMat{Float64}, TasmanianSG, AbstractVecOrMat{Float64}}","page":"API","title":"Tasmanian.evaluateBatch!","text":" evaluateBatch!(y::AbstractVecOrMat{Float64}, tsg::TasmanianSG, vals::AbstractVecOrMat{Float64})\n\nevaluates the intepolant at the points of interest and set the result in y\n\nthis should be called after the grid has been created and after values have been loaded\n\ny: a vector or a matrix    with dimensions outputs X size(vals, 2)     each columns corresponds to the value of the interpolant    for one columns of vals\n\nvals: a vector or a matrix       with first dimension equal to dimensions       each column in the array is a single requested point\n\n\n\n\n\n","category":"method"},{"location":"#Tasmanian.evaluateBatch-Tuple{TasmanianSG, AbstractVecOrMat{Float64}}","page":"API","title":"Tasmanian.evaluateBatch","text":" evaluateBatch(tsg::TasmanianSG, vals::AbstractVecOrMat{Float64})\n\nevaluates the intepolant at the points of interest and returns the result\n\nthis should be called after the grid has been created and after values have been loaded\n\nvals: a vector or a matrix       with first dimension equal to dimensions       each column in the array is a single requested point\n\noutput: a vector or a matrix         with dimensions outputs X size(vals, 2)          each columns corresponds to the value of the interpolant         for one columns of vals\n\n\n\n\n\n","category":"method"},{"location":"#Tasmanian.evaluateHierarchicalFunctions-Tuple{TasmanianSG, Any}","page":"API","title":"Tasmanian.evaluateHierarchicalFunctions","text":"evaluateHierarchicalFunctions(tsg::TasmanianSG, x)\n\nevaluates the hierarchical functions at a set of points in the domain and return a matrix with the result\n\nx: a matrix of dimensions tsg.dimensions by getNumPoints(tsg)     the columns indicate the points for evaluating the weights\n\noutput: returns a matrix of dimensions          shape == [x.shape[0], getNumPoints()]         the values of the basis functions at the points\n\n\n\n\n\n","category":"method"},{"location":"#Tasmanian.evaluateSparseHierarchicalFunctions-Tuple{TasmanianSG, Any}","page":"API","title":"Tasmanian.evaluateSparseHierarchicalFunctions","text":"evaluateSparseHierarchicalFunctions(tsg::TasmanianSG, x)\n\nevaluates the hierarchical functions at a set of points in the domain. The distinction between this function and evaluateHierarchicalFunctions() lies in the type of the returned result, namely a sparse vs a dense matrix.\n\nThe motivation for this function is that Local Polynomial and Wavelet grids usually result in sparse matrices\n\nx: a matrix with dimensions getNumDimensions() by NumX       the entries indicate the points for evaluating\n\noutput: returns a TasmanianSimpleSparseMatrix class         which is a simple class with three fields:         aPntr, aIndx, and aVals which are numpy.ndarray of types         int32, int32, and float64         NumRows and NumCols are meta fields and have values         NumRows = x.shape[0]         NumCols = getNumPoints()         The sparse matrix is compressed along the x.shape[0]         dimension, i.e., using column compressed format\n\n\n\n\n\n","category":"method"},{"location":"#Tasmanian.evaluateThreadSafe-Tuple{TasmanianSG, Any}","page":"API","title":"Tasmanian.evaluateThreadSafe","text":"evaluateThreadSafe(tsg::TasmanianSG, x)         evaluates the intepolant at a single points of interest and         returns the result         This is the thread safe version, but it does not use         acceleration of any type\n\n    this should be called after the grid has been created and after\n    values have been loaded\n\n    x: vector with length dimensions\n       the entries indicate the points for evaluating the weights\n\n    output: returns a vector of length getNumOutputs\n            the values of the interpolant at x\n\n\n\n\n\n","category":"method"},{"location":"#Tasmanian.getAccelerationType-Tuple{TasmanianSG}","page":"API","title":"Tasmanian.getAccelerationType","text":"getAccelerationType(tsg::TasmanianSG)\n\nreturns the type of acceleration set by enableAcceleration\n\n\n\n\n\n","category":"method"},{"location":"#Tasmanian.getAlpha-Tuple{TasmanianSG}","page":"API","title":"Tasmanian.getAlpha","text":"getAlpha(tsg::TasmanianSG)\n\nreturns the value of alpha in the call to makeGlobalGrid\nif makeGlobalGrid has not been called, returns 0.0\n\n\n\n\n\n","category":"method"},{"location":"#Tasmanian.getAnisotropicRefinement","page":"API","title":"Tasmanian.getAnisotropicRefinement","text":"getAnisotropicRefinement(tsg::TasmanianSG, type, min_growth, output, level_Limits = Vector{Int32}(undef, 0))\n\nCalls setAnistropicRefinement() on the inputs and then getNeededPoints().\n\n\n\n\n\n","category":"function"},{"location":"#Tasmanian.getBeta-Tuple{TasmanianSG}","page":"API","title":"Tasmanian.getBeta","text":"getBeta(tsg::TasmanianSG)\n\nreturns the value of beta in the call to makeGlobalGrid\nif makeGlobalGrid has not been called, returns 0.0\n\n\n\n\n\n","category":"method"},{"location":"#Tasmanian.getConformalTransformASIN-Tuple{TasmanianSG}","page":"API","title":"Tasmanian.getConformalTransformASIN","text":"getConformalTransformASIN(tsg::TasmanianSG)\n\nreturns Truncation from the call to setConformalTransformASIN()\n\nif setConformalTransformASIN() has not been called or if the transformed has been cleared by clearConformalTransform(), then this returns an empty matrix\n\n\n\n\n\n","category":"method"},{"location":"#Tasmanian.getDomainTransform-Tuple{TasmanianSG}","page":"API","title":"Tasmanian.getDomainTransform","text":"getDomainTransform(tsg::TasmanianSG)\n\nreturns Transform from the call to setDomainTransform()\n\nif setDomainTransform() has not been called or if the transformed has been cleared by clearDomainTransform(), then this returns an empty matrix\n\n\n\n\n\n","category":"method"},{"location":"#Tasmanian.getGPUID-Tuple{TasmanianSG}","page":"API","title":"Tasmanian.getGPUID","text":"getGPUID(tsg::TasmanianSG)\n\nreturns the GPU ID set using setGPUID\n\n\n\n\n\n","category":"method"},{"location":"#Tasmanian.getGPUMemory-Tuple{TasmanianSG, Any}","page":"API","title":"Tasmanian.getGPUMemory","text":"getGPUMemory(tsg::TasmanianSG, GPUID)\n\nreturns the total memory (in MegaBytes, 1024**2 bytes) of the corresponding GPU\n\nthis is one of several functions designed to allow basic management of multi-gpu setup with only Tasmanian module\n\n\n\n\n\n","category":"method"},{"location":"#Tasmanian.getGPUName-Tuple{TasmanianSG, Any}","page":"API","title":"Tasmanian.getGPUName","text":"getGPUName(tsg::TasmanianSG, GPUID)\n\nreturn the cuda name ID of the corresponding GPU\n\nthis is one of several functions designed to allow basic management of multi-gpu setup with only Tasmanian module\n\n\n\n\n\n","category":"method"},{"location":"#Tasmanian.getGlobalPolynomialSpace-Tuple{TasmanianSG, Any}","page":"API","title":"Tasmanian.getGlobalPolynomialSpace","text":"getGlobalPolynomialSpace(tsg::TasmanianSG, interpolation)\n\nreturns a matrix corresponding to the polynomial space that is integrated or interpolated exactly by the current grid\n\ninterpolation: boolean         indicates whether to give the space associated         with integration or interpolation\n\noutput: is a matrix of integers         size(output, 1) is equal to iDimension         size(output, 2) indicates the cardinality of the space         each columns corresponds to a multi-index associated with a         polynomial in a hierarchical tensor basis, for example,         monomials\n\n    see the manual for details\n\n\n\n\n\n","category":"method"},{"location":"#Tasmanian.getHierarchicalCoefficients-Tuple{TasmanianSG}","page":"API","title":"Tasmanian.getHierarchicalCoefficients","text":"getHierarchicalCoefficients(tsg::TasmanianSG)\n\nFor global grids, this just returns the values loaded using the call to loadNeededPoints(). In all other cases, this returns the list of hierarchical coefficients, i.e., surpluses.\n\nreturns a matrix getNumOutputs() by getNumPoints()\n\n\n\n\n\n","category":"method"},{"location":"#Tasmanian.getHierarchicalSupport-Tuple{TasmanianSG}","page":"API","title":"Tasmanian.getHierarchicalSupport","text":"getHierarchicalSupport(tsg::TasmanianSG)\n\nreturns the support of the hierarchical basis in a matrix\n\nonly local-polynomial and wavelet grids have restricted support\nthe support of all basis is restricted to the domain even if the support includes additional ares\n\noutput: a matrix of dimensions getNumDimensions() by getNumPoints()         the support entries correspond to the output of getPoints()         if x represents a point in the domain and         if abs( x[j] - getPoints()[j, i] ) > getSupport()[j, i]         then the i-th entry in evaluateHierarchicalFunctions(x)         corresponding to x is guaranteed to be zero\n\n\n\n\n\n","category":"method"},{"location":"#Tasmanian.getInterpolationWeights-Tuple{Any, Any}","page":"API","title":"Tasmanian.getInterpolationWeights","text":"getInterpolationWeights(tsg, x)\n\nreturns the interpolation weights associated with the points in getPoints()\n\nx: a vector with length dimensions    the entries indicate the points for evaluating the weights\n\noutput: a vector of length getNumPoints()         the order of the weights matches the order in getPoints()\n\n\n\n\n\n","category":"method"},{"location":"#Tasmanian.getInterpolationWeightsBatch-Tuple{Any, Any}","page":"API","title":"Tasmanian.getInterpolationWeightsBatch","text":"getInterpolationWeightsBatch(tsg, llfX):\n\nreturns the interpolation weights associated with the points in getPoints()\n\nfinds multiple weights with a single library call uses OpenMP if enabled in libtasmaniansparsegrids.so\n\nx: a matrix with first dimension getNumDimensions()    each column in the array is a single requested point\n\noutput: a matrix         with dimensions getNumPoints() X size(llfX, 2)           each row corresponds to the weight for one row of llfX\n\n\n\n\n\n","category":"method"},{"location":"#Tasmanian.getLevelLimits-Tuple{TasmanianSG}","page":"API","title":"Tasmanian.getLevelLimits","text":"getLevelLimits(tsg::TasmanianSG)\n\nreturns the limits set by the last call to make***Grid or refine returns a vector of integers corresponding to the limits for each direction, -1 indicates no limit\n\n\n\n\n\n","category":"method"},{"location":"#Tasmanian.getLicense-Tuple{}","page":"API","title":"Tasmanian.getLicense","text":"getLicense()\n\nreturns Tasmanian library hardcoded license string\n\n\n\n\n\n","category":"method"},{"location":"#Tasmanian.getLoadedPoints-Tuple{TasmanianSG}","page":"API","title":"Tasmanian.getLoadedPoints","text":"getLoadedPoints(tsg::TasmanianSG)\n\nreturns the points loaded in the existing interpolant\n\noutput: matrix of size getNumDimensions() X getNumNeeded()     each column  corresponds to one point     if getNumLoaded() == 0, returns zeros(2)\n\n\n\n\n\n","category":"method"},{"location":"#Tasmanian.getLoadedValues-Tuple{TasmanianSG}","page":"API","title":"Tasmanian.getLoadedValues","text":"getLoadedValues(tsg::TasmanianSG)\n\nReturns the model values as given to Tasmanian by the loadNeededPoints() method. The ordering will match the current internal ordering, e.g., mixing the different model values from different refinement iterations.\n\nReturns a matrix with size getNumOutputs() by getNumPoints()\n\n\n\n\n\n","category":"method"},{"location":"#Tasmanian.getNeededPoints-Tuple{TasmanianSG}","page":"API","title":"Tasmanian.getNeededPoints","text":"getNeededPoints(tsg::TasmanianSG)\n\nreturns the points needed to form the interpolant or the next level of refinement following a set***Refinement() call\n\noutput: 2-D array of size dimension X getNumNeeded()     each column  corresponds to one point     if (getNumNeeded() == 0): returns zeros(dimensions, 0)\n\n\n\n\n\n","category":"method"},{"location":"#Tasmanian.getNumDimensions-Tuple{TasmanianSG}","page":"API","title":"Tasmanian.getNumDimensions","text":"getNumDimensions(tsg::TasmanianSG)\n\nreturns the value of iDimension in the make***Grid command if no grid has been made, it returns 0\n\n\n\n\n\n","category":"method"},{"location":"#Tasmanian.getNumGPUs-Tuple{}","page":"API","title":"Tasmanian.getNumGPUs","text":"getNumGPUs()\n    returns the number of available GPUs according to cuda\n\n    this is one of several functions designed to allow basic\n    management of multi-gpu setup with only Tasmanian module\n\n\n\n\n\n","category":"method"},{"location":"#Tasmanian.getNumLoaded-Tuple{TasmanianSG}","page":"API","title":"Tasmanian.getNumLoaded","text":"getNumLoaded(tsg::TasmanianSG)\n\nreturns the number of points loaded in the existing interpolant\n\n\n\n\n\n","category":"method"},{"location":"#Tasmanian.getNumNeeded-Tuple{TasmanianSG}","page":"API","title":"Tasmanian.getNumNeeded","text":"getNumNeeded(tsg::TasmanianSG)\n\nreturns the number of points needed to form the interpolant or         form the next interpolant following a refinement\n\n\n\n\n\n","category":"method"},{"location":"#Tasmanian.getNumOutputs-Tuple{TasmanianSG}","page":"API","title":"Tasmanian.getNumOutputs","text":"getNumOutputs(tsg::TasmanianSG)\n\nreturns the value of iOutputs in the make***Grid command if no grid has been made, it returns 0\n\n\n\n\n\n","category":"method"},{"location":"#Tasmanian.getNumPoints-Tuple{TasmanianSG}","page":"API","title":"Tasmanian.getNumPoints","text":"getNumPoints(tsg::TasmanianSG)\n\nif points have been loaded, returns the same as getNumLoaded() otherwise, returns the same as getNumNeeded()\n\n\n\n\n\n","category":"method"},{"location":"#Tasmanian.getOrder-Tuple{TasmanianSG}","page":"API","title":"Tasmanian.getOrder","text":"getOrder(tsg::TasmanianSG)\n\nreturns the value of iOrder in the call to makeLocalPolynomialGrid or makeWaveletGrid if makeLocalPolynomialGrid and makeWaveletGrid have not been called, returns -1\n\n\n\n\n\n","category":"method"},{"location":"#Tasmanian.getPoints-Tuple{TasmanianSG}","page":"API","title":"Tasmanian.getPoints","text":"getPoints(tsg::TasmanianSG)\n\nif points have been loaded, gives the same as getLoadedPoints() otherwise, returns the same as getNeededPoints()\n\n\n\n\n\n","category":"method"},{"location":"#Tasmanian.getQuadratureWeights-Tuple{Any}","page":"API","title":"Tasmanian.getQuadratureWeights","text":"getQuadratureWeights(tsg)\n\nreturns the quadrature weights associated with the points in getPoints()\n\noutput: a vector of length getNumPoints()         the order of the weights matches         the order in getPoints()\n\n\n\n\n\n","category":"method"},{"location":"#Tasmanian.getRule-Tuple{TasmanianSG}","page":"API","title":"Tasmanian.getRule","text":"getRule(tsg::TasmanianSG)\n\nreturns the value of rule in the make***Grid command if makeWaveletGrid is used, returns \"wavelet\" if no grid has been made, it returns \"unknown\"\n\n\n\n\n\n","category":"method"},{"location":"#Tasmanian.getSurplusRefinement","page":"API","title":"Tasmanian.getSurplusRefinement","text":"getSurplusRefinement(tsg::TasmanianSG, tolerance, output, criteria = \"\", level_limits = Vector{Int32}(undef, 0), scale_correction = [])\n\nCalls setSurplusRefinement() on the inputs and then getNeededPoints().\n\n\n\n\n\n","category":"function"},{"location":"#Tasmanian.getVersion-Tuple{}","page":"API","title":"Tasmanian.getVersion","text":"getVersion()\n\nreturns Tasmanian library hardcoded version\n\n\n\n\n\n","category":"method"},{"location":"#Tasmanian.get_VersionMajor-Tuple{}","page":"API","title":"Tasmanian.get_VersionMajor","text":"get_VersionMajor()\n\nreturns the hardcoded version major int\n\n\n\n\n\n","category":"method"},{"location":"#Tasmanian.get_VersionMinor-Tuple{}","page":"API","title":"Tasmanian.get_VersionMinor","text":"get_VersionMinor()\n\nreturns the hardcoded version minor int\n\n\n\n\n\n","category":"method"},{"location":"#Tasmanian.integrate-Tuple{TasmanianSG}","page":"API","title":"Tasmanian.integrate","text":"integrate(tsg::TasmanianSG)\n\nreturns the integral of the interpolant\n\noutput: returns a vector of length outputs         the integral of the interpolant\n\n\n\n\n\n","category":"method"},{"location":"#Tasmanian.integrateHierarchicalFunctions-Tuple{TasmanianSG}","page":"API","title":"Tasmanian.integrateHierarchicalFunctions","text":"integrateHierarchicalFunctions(tsg::TasmanianSG)\n\nComputes the integrals of the hierarchical basis functions, i.e., the same functions computed by evaluateHierarchicalFunctions().\n\nreturns a vector of length getNumPoints()\n\n\n\n\n\n","category":"method"},{"location":"#Tasmanian.isAccelerationAvailable-Tuple{TasmanianSG, Any}","page":"API","title":"Tasmanian.isAccelerationAvailable","text":"isAccelerationAvailable(tsg::TasmanianSG, acceleration_type)\n\nreturns true if the library has been compiled with support for acceleration_type. Even if this returns false, you can use the type for enableAcceleration, but the library will default to the next available type (see the Manual)\n\n\n\n\n\n","category":"method"},{"location":"#Tasmanian.isCudaEnabled-Tuple{}","page":"API","title":"Tasmanian.isCudaEnabled","text":"isCudaEnabled()\n\nreturns true if the library has been computed with Cuda support\n\n\n\n\n\n","category":"method"},{"location":"#Tasmanian.isDpcppEnabled-Tuple{}","page":"API","title":"Tasmanian.isDpcppEnabled","text":"isDpcppEnabled()\n\nreturns true if the library has been computed with DPC++ support\n\n\n\n\n\n","category":"method"},{"location":"#Tasmanian.isFourier-Tuple{TasmanianSG}","page":"API","title":"Tasmanian.isFourier","text":"isFourier(tsg::TasmanianSG)\n\nreturns true if using a Fourier grid\n\n\n\n\n\n","category":"method"},{"location":"#Tasmanian.isGlobal-Tuple{TasmanianSG}","page":"API","title":"Tasmanian.isGlobal","text":"isGlobal(tsg::TasmanianSG)\n\nreturns true if using a global grid\n\n\n\n\n\n","category":"method"},{"location":"#Tasmanian.isHipEnabled-Tuple{}","page":"API","title":"Tasmanian.isHipEnabled","text":"isHipEnabled()\n\nreturns true if the library has been computed with HIP support\n\n\n\n\n\n","category":"method"},{"location":"#Tasmanian.isLocalPolynomial-Tuple{TasmanianSG}","page":"API","title":"Tasmanian.isLocalPolynomial","text":"isLocalPolynomial(tsg::TasmanianSG)\n\nreturns true if using a local polynomial grid\n\n\n\n\n\n","category":"method"},{"location":"#Tasmanian.isOpenMPEnabled-Tuple{}","page":"API","title":"Tasmanian.isOpenMPEnabled","text":"isOpenMPEnabled()\n\nreturns true if the library has been computed with OpenMP support\n\n\n\n\n\n","category":"method"},{"location":"#Tasmanian.isSequence-Tuple{TasmanianSG}","page":"API","title":"Tasmanian.isSequence","text":"isSequence(tsg::TasmanianSG)\n\nreturns true if using a sequence grid\n\n\n\n\n\n","category":"method"},{"location":"#Tasmanian.isSetConformalTransformASIN-Tuple{TasmanianSG}","page":"API","title":"Tasmanian.isSetConformalTransformASIN","text":"isSetConformalTransformASIN(tsg::TasmanianSG)\n\nreturns true if conformal transform is set returns false otherwise\n\nsee: setConformalTransformASIN()\n\n\n\n\n\n","category":"method"},{"location":"#Tasmanian.isSetDomainTransform-Tuple{TasmanianSG}","page":"API","title":"Tasmanian.isSetDomainTransform","text":"isSetDomainTransform(tsg::TasmaninaSG) returns true if the grid is defined for non-canonical domain         returns false if using a canonical domain\n\n\n\n\n\n","category":"method"},{"location":"#Tasmanian.isWavelet-Tuple{TasmanianSG}","page":"API","title":"Tasmanian.isWavelet","text":"isWavelet(tsg::TasmanianSG)\n\nreturns true if using a local wavelet grid\n\n\n\n\n\n","category":"method"},{"location":"#Tasmanian.loadNeededPoints!-Tuple{TasmanianSG, AbstractArray{Float64}}","page":"API","title":"Tasmanian.loadNeededPoints!","text":"loadNeededPoints!(tsg::TasmanianSG, vals::Array{Float64})\n\nloads the values of the target function at the needed points if there are no needed points, this reset the currently loaded values\n\nvals: an array with dimensions outputs X getNumNeeded()        each column corresponds to the values of the outputs at       the corresponding needed point. The order and leading       dimension must match the points obtained from       getNeededPoints()\n\n\n\n\n\n","category":"method"},{"location":"#Tasmanian.loadNeededValues!-Tuple{TasmanianSG, Array{Float64}}","page":"API","title":"Tasmanian.loadNeededValues!","text":"loadNeededValues!(tsg::TasmanianSG, vals::Array{Float64})\n\nAlias of loadNeededPoints()\n\n\n\n\n\n","category":"method"},{"location":"#Tasmanian.makeFourierGrid!-Tuple{TasmanianSG}","page":"API","title":"Tasmanian.makeFourierGrid!","text":"makeFourierGrid!(tsg::TasmanianSG; type, anisotropic_weights=Vector{Int32}(undef, 0), level_limits=Vector{Int32}(undef, 0))\n\ncreates a new sparse grid using a Fourier rule discards any existing grid held by this class\n\ntype: string identifying the tensor selection strategy       'level'     'curved'     'hyperbolic'     'tensor'       'iptotal'   'ipcurved'   'iphyperbolic'   'iptensor'       'qptotal'   'qpcurved'   'qphyperbolic'   'qptensor'\n\nanisotropic_weights: list or array of weights                      length must be iDimension or 2*iDimension                      the first tsg.dimensions weights must be positive                      see the manual for details\n\n\n\n\n\n","category":"method"},{"location":"#Tasmanian.makeGlobalGrid!-Tuple{TasmanianSG}","page":"API","title":"Tasmanian.makeGlobalGrid!","text":"makeGlobalGrid!(tsg::TasmanianSG; type, rule, anisotropic_weights=Vector{Int32}(undef, 0), alpha=0.0, beta=0.0, custom_filename=\"\", level_limits=Vector{Int32}(undef, 0))\n\ncreates a new sparse grid using a global polynomial rule discards any existing grid held by tsg\n\ntype: string identifying the tensor selection strategy      level     curved     hyperbolic     tensor      iptotal   ipcurved   iphyperbolic   iptensor      qptotal   qpcurved   qphyperbolic   qptensor\n\nrule: string (defines the 1-D rule that induces the grid)\n\n   Interpolation rules\n\n      Note: the quadrature induced by those rules is constructed\n            by integrating the interpolant\n\n      `clenshaw-curtis`    `clenshaw-curtis-zero`      `fejer2`\n      `rleja`    `rleja-odd`  `rleja-double2`   `rleja-double4`\n      `rleja-shifted`   `rleja-shifted-even`\n      `max-lebesgue`    `max-lebesgue-odd`\n      `min-lebesgue`    `min-lebesgue-odd`\n      `leja`            `leja-odd`\n      `min-delta`       `min-delta-odd`\n\n      `chebyshev`       `chebyshev-odd`\n        approximation using roots of Chebyshev polynomials\n        non-nested case (in contrast to Clenshaw-Curtis nodes)\n\n   Quadrature rules, the weights target exactness with respect\n                     to the highest polynomial degree possible\n\n       `gauss-legendre`  `gauss-legendre-odd`\n        approximation using roots of polynomials orthogonal in\n        measure Uniform\n\n       `gauss-patterson`  (a.k.a. nested Gauss-Legendre)\n        Note: the nodes and weights are hard-coded hence there\n        is a limit on the highest possible depth\n\n       `gauss-chebyshev1`  `gauss-chebyshev1-odd`\n       `gauss-chebyshev2`  `gauss-chebyshev2-odd`\n         approximation using roots of polynomials orthogonal in\n         measures  1/sqrt(1-x^2) and sqrt(1-x^2)  (respectively)\n\n      `gauss-gegenbauer`  `gauss-gegenbauer-odd`\n        approximation using roots of polynomials orthogonal in\n        measure (1-x^2)^alpha\n\n      `gauss-jacobi`\n        approximation using roots of polynomials orthogonal in\n        measure (1-x)^alpha * (1+x)^beta\n\n      `gauss-laguerre`\n        approximation using roots of polynomials orthogonal in\n        measure x^alpha * epx(-x)\n\n      `gauss-hermite`  `gauss-hermite-odd`\n        approximation using roots of polynomials orthogonal in\n        measure |x|^alpha * epx(-x^2)\n\nanisotropic_weights: list or array of weights (Int)                      length must be dimension or 2*dimension                      the first dimension weights must be positive                      see the manual for details\n\nalpha, beta: Float64       alpha : the alpha parameter for Gegenbauer, Jacobi,                Hermite and Laguerre rules       beta  : the beta parameter for Jacobi rules\n\ncustom_filename: string giving the path to the file with              custom-tabulated rule\n\n\n\n\n\n","category":"method"},{"location":"#Tasmanian.makeLocalPolynomialGrid!-Tuple{TasmanianSG}","page":"API","title":"Tasmanian.makeLocalPolynomialGrid!","text":"makeLocalPolynomialGrid!(tsg::TasmanianSG; order=1, rule=\"localp\", level_limits=Vector{Int32}(undef, 0))\n\ncreates a new sparse grid using a local polynomial rule discards any existing grid held by TSG\n\norder: int (must be -1 or bigger)         -1 indicates largest possible order          1 means linear, 2 means quadratic, etc.          0 means piece-wise constant, it has different hierarchy            then the other orders, most notably the 1D rule            triples the number of points per level (as opposed            to double for the other cases)\n\nrule: string (defines the 1-D rule that induces the grid)       localp localp-zero  semi-localp  localp-boundary\n\n\n\n\n\n","category":"method"},{"location":"#Tasmanian.makeSequenceGrid!-Tuple{TasmanianSG}","page":"API","title":"Tasmanian.makeSequenceGrid!","text":"makeSequenceGrid!(tsg::TasmanianSG; type, rule, anisotropic_weights=Vector{Int32}(undef, 0), level_limits=Vector{Int32}(undef, 0))\n\ncreates a new sparse grid using a sequence rule discards any existing grid held by this class\n\ntype: string identifying the tensor selection strategy       'level'     'curved'     'hyperbolic'     'tensor'       'iptotal'   'ipcurved'   'iphyperbolic'   'iptensor'       'qptotal'   'qpcurved'   'qphyperbolic'   'qptensor'\n\nrule: string (defines the 1-D rule that induces the grid)       'leja'       'rleja'      'rleja-shifted'       'max-lebesgue'   'min-lebesgue'   'min-delta'\n\nanisotropic_weights: list or array of weights                      length must be tsg.dimensions or 2*tsg.dimensions                      the first tsg.dimensions weights must be positive                      see the manual for details\n\n\n\n\n\n","category":"method"},{"location":"#Tasmanian.makeWaveletGrid!-Tuple{Any}","page":"API","title":"Tasmanian.makeWaveletGrid!","text":"makeWaveletGrid!(tsg::TasmanianSG; order=1, level_limits=Vector{Int32}(undef, 0))\n\ncreates a new sparse grid using a wavelet rule discards any existing grid held by tsg\n\norder: Int (must be 1 or 3)        only wavelets of order 1 and 3 are implemented\n\n\n\n\n\n","category":"method"},{"location":"#Tasmanian.mergeRefinement-Tuple{TasmanianSG}","page":"API","title":"Tasmanian.mergeRefinement","text":"mergeRefinement(tsg::TasmanianSG)\n\ncombines the loaded and needed points into a single grid it also invalidates any currently loaded values, i.e., the grid cannot be used for internal integration or interpolation until loadNeededPoints() or setHierarchicalCoefficients() is called (even if those have been called before)\n\nif getNumNeeded() == 0, this call will have no effect\n\n\n\n\n\n","category":"method"},{"location":"#Tasmanian.printStats-Tuple{TasmanianSG}","page":"API","title":"Tasmanian.printStats","text":"printStats(tsg::TasmanianSG)\n\ncalls the library printStats() function, which displays basic information about this instance of the grid\n\n\n\n\n\n","category":"method"},{"location":"#Tasmanian.removePointsByHierarchicalCoefficient!","page":"API","title":"Tasmanian.removePointsByHierarchicalCoefficient!","text":"removePointsByHierarchicalCoefficient!(tsg::TasmanianSG, tolerance, output = -1, scale_correction = [], NumKeep = -1)\n\nremoves any points in the grid with relative surplus that exceeds the tolerance or keeps the set number of points with largest surplus\n\ntolerance: float (positive)            the relative surplus tolerance, i.e.,            we keep only for points associated with surplus            that exceeds the tolerance            if NumKeep is positive, then tolerance is ignored\n\noutput: int (indicates the output to use)         selects which output to consider         accept -1 to indicate all outputs\n\nscale_correction: vector or matrix                   if output = -1 and getNumOutputs() > 1,                   then using matrix with shape                   getNumOutputs() X getNumLoaded() with                   one weight per hierarchical coefficient                   if output > -1, then using a vector with                   one weight per point\n\nNumKeep: int (positive or equal to -1)          indicates the number of points to keep          if set to -1 then tolerance is used as a cutoff          if positive then the given number of points will be kept\n\n\n\n\n\n","category":"function"},{"location":"#Tasmanian.setAnisotropicRefinement!","page":"API","title":"Tasmanian.setAnisotropicRefinement!","text":"setAnisotropicRefinement!(tsg::TasmanianSG, type, min_growth, output, level_limits = Vector{Int32}(undef, 0))\n\nestimates anisotropic coefficients from the current set of loaded points and updates the grid with the best points according to the estimate\n\ntype: string identifying the estimate to use (see the Manual)       recommended: 'iptotal'   'ipcurved'\n\nmin_growth: int (positive)             minimum number of new points to include in the new grid\n\noutput: int (indicates the output to use) selects which output to use for refinement         sequence grids, using -1 indicates to use all outputs\n\nlevel_limits: (if not empty) will be used to overwrite the currently set limits. The limits must be either empty               or have size getNumDimensions(); if empty, the current set of limits will be used.\n\n\n\n\n\n","category":"function"},{"location":"#Tasmanian.setConformalTransformASIN!-Tuple{TasmanianSG, Any}","page":"API","title":"Tasmanian.setConformalTransformASIN!","text":"setConformalTransformASIN!(tsg::TasmanianSG, truncation)\n\nsets conformal domain transform based on truncated Maclaurin series of arcsin()\n\ntruncation: a vector of non-negative integers             indicating the truncation order in each direction             0 indicates no transform applied to this direction\n\n\n\n\n\n","category":"method"},{"location":"#Tasmanian.setDomainTransform!-Tuple{TasmanianSG, VecOrMat}","page":"API","title":"Tasmanian.setDomainTransform!","text":"setDomainTransform!(tsg::TasmanianSG, Transform::VecOrMat)\n\nsets the lower and upper bound for each dimension\n\nNote: gauss-laguerre and gauss-hermite rules are defined on       unbounded domain, in which case  this sets the       shift and scale parameters, consult the manual\n\nTransform: a matrix of size dimension X 2            transform specifies the lower and upper bound            of the domain in each direction.\n\n       For gauss-laguerre and gauss-hermite grids, the\n       transform gives the a and b parameters of the\n       weights\n        exp(-b (x - a))\n        exp(-b (x - a)^2)\n\n\n\n\n\n","category":"method"},{"location":"#Tasmanian.setGPUID!-Tuple{TasmanianSG, Any}","page":"API","title":"Tasmanian.setGPUID!","text":"setGPUID!(tsg::TasmanianSG, GPUID)\n\nwhen using cuda on a machine with multiple GPUs, this helps set the GPU for this grid NOTE: each instance of the sparse grids class holds a separate       instance of GPUID and different grids can be assigned to       different GPUs (on multi-gpu system) GPUID can be changed at any time, however, this will cause some of the internal cache to be invalidated and it may lead to extraneous data movement\n\ncalling read or make***Grid will reset the selected GPU\n\ndefaults to 0\n\nthis doesn't do anything unless enableAcceleration is called using a \"gpu-\" acceleration type\n\n\n\n\n\n","category":"method"},{"location":"#Tasmanian.setHierarchicalCoefficients!-Tuple{TasmanianSG, Any}","page":"API","title":"Tasmanian.setHierarchicalCoefficients!","text":"setHierarchicalCoefficients!(tsg::TasmanianSG, coefficients)\n\nLocal polynomial, Wavelet, and Sequence grids construct  approximation using hierarchical coefficients based on the  loaded values. This function does the opposite, the hierarchical  coefficients are loaded directly and the values are computed  based on the coefficients. The coefficients can be computed,  e.g., by solving least-squares or compressed sensing problem             min || A c - f ||  where A is a matrix returned by evaluateHierarchicalFunctions()  or evaluateSparseHierarchicalFunctions() for a set of points  x; f are the values of the target function at the x  points; and c is the vector with corresponding hierarchical  coefficients.\n\nIf there is a pending refinement, i.e., getNumLoaded() != 0 and  getNumNeeded() != 0, then the refinement is discarded (since it  was computed based on the old and now obsolete values)\n\ncoefficients: a matrix with dimensions getNumOutputs() by getNumPoints()                each column corresponds to the values of the                coefficients at the corresponding point.                The order and leading dimension must match the                points obtained form getPoints(), the same                order as the second dimension of                evaluateHierarchicalFunctions().                This matrix must be of type Matrix{ComplexF64} when                using a Fourier grid.\n\n\n\n\n\n","category":"method"},{"location":"#Tasmanian.setSurplusRefinement!-Tuple{TasmanianSG, Float64}","page":"API","title":"Tasmanian.setSurplusRefinement!","text":"setSurplusRefinement!(tsg::TasmanianSG, tol::Float64; output::Int=-1, refinement_type::AbstractString=\"\", level_limits=Vector{Int32}(undef, 0), scale_correction = Vector{Float64}(undef, 0))\n\nusing hierarchical surplusses as an error indicator, the surplus refinement adds points to the grid to improve accuracy\n\nwhen using sequence grids: this algorithm corresponds to the                            greedy Knapsack problem\n\nwhen using local polynomial or wavelet grids, this call                          corresponds to local spatial refinement\n\ntolerance: float (non-negative)            the relative error tolerance, i.e.,            we refine only for points associated with surplus            that exceeds the tolerance\n\noutput: int (indicates the output to use)          selects which output to use for refinement          sequence and local polynomial grids accept -1 to          indicate all outputs\n\nrefinement_type: hierarchical and direction refinement strategy                  'classic'  'parents'   'direction'   'fds'   'stable'                  applicable only for Local Polynomial and Wavelet grids\n\nscalecorrection: matrix of non-negative numbers                   Instead of comparing the normalized surpluses to                   the tolerance, the scaled surplus will be used.                   The correction allows to manually guide the                   refinement process.                   The surplus of the j-th output of the i-th point                   will be scaled by scalecorrection[i][j].                   scalecorrection.shape[0] must be equal to                   getNumLoaded()                   If empty, the scale is assumed 1.0                   scalecorrection.shape[1] must be equal to the                   number of outputs used in the process, which is                   equal to getNumOutputs() for output == -1,                   or 1 if output > -1.\n\n\n\n\n\n","category":"method"},{"location":"#Tasmanian.updateFourierGrid!-Tuple{TasmanianSG, Any, Any}","page":"API","title":"Tasmanian.updateFourierGrid!","text":"updateFourierGrid!(tsg::TasmanianSG, depth, type; anisotropic_weights=Vector{Int32}(undef, 0), level_limits=Vector{Int32}(undef, 0))\n\nadds the points defined by depth, type and anisotropy to the existing grid\n\nbasically, the same as calling makeFourierGrid() with rule,            of this grid and the new depth, type and            anisotropic_weights then adding the resulting points            to the current grid\n\ninputs: see help(makeGlobalGrid)\n\n\n\n\n\n","category":"method"},{"location":"#Tasmanian.updateGlobalGrid!-Tuple{TasmanianSG, Any, Any}","page":"API","title":"Tasmanian.updateGlobalGrid!","text":"updateGlobalGrid!(tsg::TasmanianSG, depth, type; anisotropicweights=Vector{Int32}(undef, 0), levellimits=Vector{Int32}(undef, 0)) adds the points defined by depth, type and anisotropy to the existing grid\n\nbasically, the same as calling makeGlobalGrid with rule,            alpha and beta of this grid and the new depth,            type and anisotropic_weights then adding the            resulting points to the current grid\n\ninputs: see help(makeGlobalGrid)\n\n\n\n\n\n","category":"method"},{"location":"#Tasmanian.updateSequenceGrid!-Tuple{TasmanianSG, Any, Any}","page":"API","title":"Tasmanian.updateSequenceGrid!","text":"updateSequenceGrid!(tsg::TasmanianSG, depth, type; anisotropic_weights=Vector{Int32}(undef, 0), level_limits=Vector{Int32}(undef, 0))\n\nadds the points defined by depth, type and anisotropy to the existing grid\n\nbasically, the same as calling makeSequenceGrid() with rule,            of this grid and the new depth, type and            anisotropic_weights then adding the resulting points            to the current grid\n\ninputs: see help(makeSequenceGrid)\n\n\n\n\n\n","category":"method"}]
}
