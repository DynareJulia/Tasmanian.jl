<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API · Tasmanian</title><meta name="title" content="API · Tasmanian"/><meta property="og:title" content="API · Tasmanian"/><meta property="twitter:title" content="API · Tasmanian"/><meta name="description" content="Documentation for Tasmanian."/><meta property="og:description" content="Documentation for Tasmanian."/><meta property="twitter:description" content="Documentation for Tasmanian."/><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="search_index.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>Tasmanian</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/DynareJulia/Tasmanian.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/DynareJulia/Tasmanian.jl/blob/main/docs/src/index.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="API"><a class="docs-heading-anchor" href="#API">API</a><a id="API-1"></a><a class="docs-heading-anchor-permalink" href="#API" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.read-Tuple{TasmanianSG, Any}" href="#Base.read-Tuple{TasmanianSG, Any}"><code>Base.read</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">read(tsg::TasmanianSG, filename)</code></pre><p>reads the <code>tsg</code> grid from a file discards any existing grid held by <code>tsg</code></p><p><code>tsg</code>: an existing grid <code>filename</code>: string indicating a grid file where a grid was             already written using write from Julia or any other             Tasmanian interface</p><p>output: Bool         <code>true</code>: the read was successful         <code>false</code>: the read failed,                  check for an error message</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DynareJulia/Tasmanian.jl/blob/63629550ff87f2b47fd4d648d1d3ec81be894d7a/src/TSG.jl#L78-L93">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.write-Tuple{TasmanianSG, Any}" href="#Base.write-Tuple{TasmanianSG, Any}"><code>Base.write</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">write(tsg::TasmanianSG, filename; binary::Bool=true)</code></pre><p>writes the <code>tsg</code> grid to a file</p><p><code>tsg</code>: an existing grid <code>filename</code>: string indicating a grid file where a grid will be written <code>binary</code>: Bool     <code>true</code>: write to a binary file     <code>false</code>: write to an ASCII file</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DynareJulia/Tasmanian.jl/blob/63629550ff87f2b47fd4d648d1d3ec81be894d7a/src/TSG.jl#L102-L112">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Tasmanian.clearConformalTransform-Tuple{TasmanianSG}" href="#Tasmanian.clearConformalTransform-Tuple{TasmanianSG}"><code>Tasmanian.clearConformalTransform</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">clearConformalTransform(tsg::TasmanianSG)</code></pre><p>resets the conformal domain transform loaded values will be kept, however, the values now correspond to canonical points and may be invalid for your application</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DynareJulia/Tasmanian.jl/blob/63629550ff87f2b47fd4d648d1d3ec81be894d7a/src/TSG.jl#L1157-L1162">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Tasmanian.clearDomainTransform-Tuple{TasmanianSG}" href="#Tasmanian.clearDomainTransform-Tuple{TasmanianSG}"><code>Tasmanian.clearDomainTransform</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">clearDomainTransform(tsg::TasmanianSG)</code></pre><p>resets the domain to canonical loaded values will be kept, however, the values now correspond to canonical points and may be invalid for your application</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DynareJulia/Tasmanian.jl/blob/63629550ff87f2b47fd4d648d1d3ec81be894d7a/src/TSG.jl#L1100-L1105">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Tasmanian.clearLevelLimits-Tuple{TasmanianSG}" href="#Tasmanian.clearLevelLimits-Tuple{TasmanianSG}"><code>Tasmanian.clearLevelLimits</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">clearLevelLimits(tsg::TasmanianSG)</code></pre><p>clears the limits set by the last make***Grid or refine command if no limits are set, this has no effect</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DynareJulia/Tasmanian.jl/blob/63629550ff87f2b47fd4d648d1d3ec81be894d7a/src/TSG.jl#L1183-L1188">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Tasmanian.clearRefinement-Tuple{TasmanianSG}" href="#Tasmanian.clearRefinement-Tuple{TasmanianSG}"><code>Tasmanian.clearRefinement</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">clearRefinement(tsg::TasmanianSG)</code></pre><p>clear the last call to set***Refinement, only works if called before the points are loaded, i.e., before loadNeededPoints()</p><p>if getNumNeeded() == 0, this call will have no effect</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DynareJulia/Tasmanian.jl/blob/63629550ff87f2b47fd4d648d1d3ec81be894d7a/src/TSG.jl#L1418-L1426">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Tasmanian.copyGrid" href="#Tasmanian.copyGrid"><code>Tasmanian.copyGrid</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">copyGrid(tsg::TasmanianSG, outputs_begin = 0, outputs_end = -1)</code></pre><p>accepts an instance of TasmanianSparseGrid class and creates a hard copy of the class and all included data original class is not modified</p><p>tsg: instance of TasmanianSG      the source for the copy</p><p>outputs_begin: integer indicating the first output to copy</p><p>outputs<em>end: integer one bigger than the last output to copy             if set to -1, all outputs from outputs</em>begin to             the end will be copied</p><p>Examples:</p><p>copyGrid(other, 0, -1) # copy all outputs (default) copyGrid(other, 0, getNumOutputs(other)) # also copy all copyGrid(other, 0, 3) # copy outputs 0, 1, and 2 copyGrid(other, 1, 4) # copy outputs 1, 2, and 3</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DynareJulia/Tasmanian.jl/blob/63629550ff87f2b47fd4d648d1d3ec81be894d7a/src/TSG.jl#L402-L424">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Tasmanian.differentiate!-Tuple{VecOrMat{Float64}, TasmanianSG, Vector{Float64}}" href="#Tasmanian.differentiate!-Tuple{VecOrMat{Float64}, TasmanianSG, Vector{Float64}}"><code>Tasmanian.differentiate!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">differentiate!(jacobian::VecOrMat{Float64}, tsg::TasmanianSG, x::AbstractVector{Float64})</code></pre><p>returns the derivative (Jacobian or gradient vector) of the interpolant</p><p>jacobian:  a vector or a matrix            with dimensions dimensions X outputs            each row corresponds to the value of the interpolant            for one columns of vals tsg:  an instance of TasmanianSG x: a vector with length dimensions which is the evaluation point</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DynareJulia/Tasmanian.jl/blob/63629550ff87f2b47fd4d648d1d3ec81be894d7a/src/TSG.jl#L974-L985">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Tasmanian.differentiate-Tuple{TasmanianSG, Vector{Float64}}" href="#Tasmanian.differentiate-Tuple{TasmanianSG, Vector{Float64}}"><code>Tasmanian.differentiate</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">differentiate(tsg::TasmanianSG, x::Vector{Float64})</code></pre><p>returns the derivative (Jacobian or gradient vector) of the interpolant as a vector or a matrix with dimensions dimensions X outputs each row corresponds to the value of the interpolant</p><p>tsg:  an instance of TasmanianSG x: a vector with length iDimensions which is the evaluation point</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DynareJulia/Tasmanian.jl/blob/63629550ff87f2b47fd4d648d1d3ec81be894d7a/src/TSG.jl#L1002-L1011">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Tasmanian.enableAcceleration-Tuple{TasmanianSG, Any}" href="#Tasmanian.enableAcceleration-Tuple{TasmanianSG, Any}"><code>Tasmanian.enableAcceleration</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">enableAcceleration(tsg::TasmanianSG, acceleration_type, GPUID = 0)</code></pre><p>Enables the use of accelerated backend libraries and extensions, such as BLAS and CUDA. Each acceleration type requires corresponding CMake compile options, otherwise the backend will fallback to the closest available options.</p><p>sAccelerationType: string</p><p>&#39;none&#39;       core fallback mode, relies on sequential implementation       if compiled with Tasmanian<em>ENABLE</em>OPENMP this will use       simple &quot;omp parallel for&quot; to take advantage of multiple cpu cores</p><p>&#39;cpu-blas&#39;       uses BLAS level 2 and 3 functions for acceleration of batch       evaluations       requires Tasmanian<em>ENABLE</em>BLAS=ON       this is the default mode, if available</p><p>&#39;gpu-default&#39;       uses CUDA kernels, cuBlas, cuSparse and MAGMA libraries for       accelerated matrix operations, e.g., cublasDgemm       refer to TasGrid::TypeAcceleration for more details</p><p>&#39;gpu_cublas&#39;       uses the Nvidia cuBlas and cuSparse libraries</p><p>&#39;gpu-cuda&#39;       uses custom CUDA kernels in addition to the accelerated       linear algebra libraries</p><p>&#39;gpu-magma&#39;       uses the custom CUDA kernels and the MAGMA library in place       of the default Nvidia libraries</p><p>GPUID: integer       indicates the GPU device to use, if set to None then device       zero will be used first or the device set with setGPUID()</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DynareJulia/Tasmanian.jl/blob/63629550ff87f2b47fd4d648d1d3ec81be894d7a/src/TSG.jl#L1771-L1812">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Tasmanian.estimateAnisotropicCoefficients-Tuple{TasmanianSG, Any, Any}" href="#Tasmanian.estimateAnisotropicCoefficients-Tuple{TasmanianSG, Any, Any}"><code>Tasmanian.estimateAnisotropicCoefficients</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">estimateAnisotropicCoefficients(tsg::TasmanianSG, type, output)</code></pre><p>returns the estimate of the anisotropic coefficients from the current set of loaded points see the manual</p><p>type: string identifying the estimate to use (see the Manual)        recommended: &#39;iptotal&#39;   &#39;ipcurved&#39;</p><p>output: int (indicates the output to use)      selects which output to use for refinement      sequence grids accept -1 to indicate all outputs</p><p>returns vector of length getNumDimensions() or 2*getNumDimensions()         the first set of getNumDimensions() entries correspond to the xi coefficients          the second set of getNumDimensions() entries correspond to the eta coefficients</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DynareJulia/Tasmanian.jl/blob/63629550ff87f2b47fd4d648d1d3ec81be894d7a/src/TSG.jl#L1265-L1282">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Tasmanian.evaluate-Tuple{TasmanianSG, Any}" href="#Tasmanian.evaluate-Tuple{TasmanianSG, Any}"><code>Tasmanian.evaluate</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">evaluate(tsg::TasmanianSG, x)</code></pre><p>evaluates the intepolant at a single points of interest and returns the result This is the accelerated version using the selected acceleration type, but it is potentially not thread safe</p><p>this should be called after the grid has been created and after values have been loaded</p><p>x: a vector with length getNumDimensions()    the entries indicate the points for evaluating the weights</p><p>output: returns vector of length getNumOutputs()         the values of the interpolant at fX</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DynareJulia/Tasmanian.jl/blob/63629550ff87f2b47fd4d648d1d3ec81be894d7a/src/TSG.jl#L843-L858">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Tasmanian.evaluateBatch!-Tuple{AbstractVecOrMat{Float64}, TasmanianSG, AbstractVecOrMat{Float64}}" href="#Tasmanian.evaluateBatch!-Tuple{AbstractVecOrMat{Float64}, TasmanianSG, AbstractVecOrMat{Float64}}"><code>Tasmanian.evaluateBatch!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs"> evaluateBatch!(y::AbstractVecOrMat{Float64}, tsg::TasmanianSG, vals::AbstractVecOrMat{Float64})</code></pre><p>evaluates the intepolant at the points of interest and set the result in <code>y</code></p><p>this should be called after the grid has been created and after values have been loaded</p><p>y: a vector or a matrix    with dimensions outputs X size(vals, 2)     each columns corresponds to the value of the interpolant    for one columns of vals</p><p>vals: a vector or a matrix       with first dimension equal to dimensions       each column in the array is a single requested point</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DynareJulia/Tasmanian.jl/blob/63629550ff87f2b47fd4d648d1d3ec81be894d7a/src/TSG.jl#L907-L923">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Tasmanian.evaluateBatch-Tuple{TasmanianSG, AbstractVecOrMat{Float64}}" href="#Tasmanian.evaluateBatch-Tuple{TasmanianSG, AbstractVecOrMat{Float64}}"><code>Tasmanian.evaluateBatch</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs"> evaluateBatch(tsg::TasmanianSG, vals::AbstractVecOrMat{Float64})</code></pre><p>evaluates the intepolant at the points of interest and returns the result</p><p>this should be called after the grid has been created and after values have been loaded</p><p>vals: a vector or a matrix       with first dimension equal to dimensions       each column in the array is a single requested point</p><p>output: a vector or a matrix         with dimensions outputs X size(vals, 2)          each columns corresponds to the value of the interpolant         for one columns of vals</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DynareJulia/Tasmanian.jl/blob/63629550ff87f2b47fd4d648d1d3ec81be894d7a/src/TSG.jl#L876-L893">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Tasmanian.evaluateHierarchicalFunctions-Tuple{TasmanianSG, Any}" href="#Tasmanian.evaluateHierarchicalFunctions-Tuple{TasmanianSG, Any}"><code>Tasmanian.evaluateHierarchicalFunctions</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">evaluateHierarchicalFunctions(tsg::TasmanianSG, x)</code></pre><p>evaluates the hierarchical functions at a set of points in the domain and return a matrix with the result</p><p>x: a matrix of dimensions tsg.dimensions by getNumPoints(tsg)     the columns indicate the points for evaluating the weights</p><p>output: returns a matrix of dimensions          shape == [x.shape[0], getNumPoints()]         the values of the basis functions at the points</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DynareJulia/Tasmanian.jl/blob/63629550ff87f2b47fd4d648d1d3ec81be894d7a/src/TSG.jl#L1560-L1572">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Tasmanian.evaluateSparseHierarchicalFunctions-Tuple{TasmanianSG, Any}" href="#Tasmanian.evaluateSparseHierarchicalFunctions-Tuple{TasmanianSG, Any}"><code>Tasmanian.evaluateSparseHierarchicalFunctions</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">evaluateSparseHierarchicalFunctions(tsg::TasmanianSG, x)</code></pre><p>evaluates the hierarchical functions at a set of points in the domain. The distinction between this function and evaluateHierarchicalFunctions() lies in the type of the returned result, namely a sparse vs a dense matrix.</p><p>The motivation for this function is that Local Polynomial and Wavelet grids usually result in sparse matrices</p><p>x: a matrix with dimensions getNumDimensions() by NumX       the entries indicate the points for evaluating</p><p>output: returns a TasmanianSimpleSparseMatrix class         which is a simple class with three fields:         aPntr, aIndx, and aVals which are numpy.ndarray of types         int32, int32, and float64         NumRows and NumCols are meta fields and have values         NumRows = x.shape[0]         NumCols = getNumPoints()         The sparse matrix is compressed along the x.shape[0]         dimension, i.e., using column compressed format</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DynareJulia/Tasmanian.jl/blob/63629550ff87f2b47fd4d648d1d3ec81be894d7a/src/TSG.jl#L1617-L1640">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Tasmanian.evaluateThreadSafe-Tuple{TasmanianSG, Any}" href="#Tasmanian.evaluateThreadSafe-Tuple{TasmanianSG, Any}"><code>Tasmanian.evaluateThreadSafe</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>evaluateThreadSafe(tsg::TasmanianSG, x)         evaluates the intepolant at a single points of interest and         returns the result         This is the thread safe version, but it does not use         acceleration of any type</p><pre><code class="nohighlight hljs">    this should be called after the grid has been created and after
    values have been loaded

    x: vector with length dimensions
       the entries indicate the points for evaluating the weights

    output: returns a vector of length getNumOutputs
            the values of the interpolant at x</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DynareJulia/Tasmanian.jl/blob/63629550ff87f2b47fd4d648d1d3ec81be894d7a/src/TSG.jl#L810-L825">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Tasmanian.getAccelerationType-Tuple{TasmanianSG}" href="#Tasmanian.getAccelerationType-Tuple{TasmanianSG}"><code>Tasmanian.getAccelerationType</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">getAccelerationType(tsg::TasmanianSG)</code></pre><p>returns the type of acceleration set by enableAcceleration</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DynareJulia/Tasmanian.jl/blob/63629550ff87f2b47fd4d648d1d3ec81be894d7a/src/TSG.jl#L1827-L1830">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Tasmanian.getAlpha-Tuple{TasmanianSG}" href="#Tasmanian.getAlpha-Tuple{TasmanianSG}"><code>Tasmanian.getAlpha</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">getAlpha(tsg::TasmanianSG)

returns the value of alpha in the call to makeGlobalGrid
if makeGlobalGrid has not been called, returns 0.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DynareJulia/Tasmanian.jl/blob/63629550ff87f2b47fd4d648d1d3ec81be894d7a/src/TSG.jl#L520-L525">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Tasmanian.getAnisotropicRefinement" href="#Tasmanian.getAnisotropicRefinement"><code>Tasmanian.getAnisotropicRefinement</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">getAnisotropicRefinement(tsg::TasmanianSG, type, min_growth, output, level_Limits = Vector{Int32}(undef, 0))</code></pre><p>Calls setAnistropicRefinement() on the inputs and then getNeededPoints().</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DynareJulia/Tasmanian.jl/blob/63629550ff87f2b47fd4d648d1d3ec81be894d7a/src/TSG.jl#L1255-L1259">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Tasmanian.getBeta-Tuple{TasmanianSG}" href="#Tasmanian.getBeta-Tuple{TasmanianSG}"><code>Tasmanian.getBeta</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">getBeta(tsg::TasmanianSG)

returns the value of beta in the call to makeGlobalGrid
if makeGlobalGrid has not been called, returns 0.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DynareJulia/Tasmanian.jl/blob/63629550ff87f2b47fd4d648d1d3ec81be894d7a/src/TSG.jl#L530-L535">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Tasmanian.getConformalTransformASIN-Tuple{TasmanianSG}" href="#Tasmanian.getConformalTransformASIN-Tuple{TasmanianSG}"><code>Tasmanian.getConformalTransformASIN</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">getConformalTransformASIN(tsg::TasmanianSG)</code></pre><p>returns Truncation from the call to setConformalTransformASIN()</p><p>if setConformalTransformASIN() has not been called or if the transformed has been cleared by clearConformalTransform(), then this returns an empty matrix</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DynareJulia/Tasmanian.jl/blob/63629550ff87f2b47fd4d648d1d3ec81be894d7a/src/TSG.jl#L1165-L1172">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Tasmanian.getDomainTransform-Tuple{TasmanianSG}" href="#Tasmanian.getDomainTransform-Tuple{TasmanianSG}"><code>Tasmanian.getDomainTransform</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">getDomainTransform(tsg::TasmanianSG)</code></pre><p>returns Transform from the call to setDomainTransform()</p><p>if setDomainTransform() has not been called or if the transformed has been cleared by clearDomainTransform(), then this returns an empty matrix</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DynareJulia/Tasmanian.jl/blob/63629550ff87f2b47fd4d648d1d3ec81be894d7a/src/TSG.jl#L1108-L1115">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Tasmanian.getGPUID-Tuple{TasmanianSG}" href="#Tasmanian.getGPUID-Tuple{TasmanianSG}"><code>Tasmanian.getGPUID</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">getGPUID(tsg::TasmanianSG)</code></pre><p>returns the GPU ID set using setGPUID</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DynareJulia/Tasmanian.jl/blob/63629550ff87f2b47fd4d648d1d3ec81be894d7a/src/TSG.jl#L1875-L1879">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Tasmanian.getGPUMemory-Tuple{TasmanianSG, Any}" href="#Tasmanian.getGPUMemory-Tuple{TasmanianSG, Any}"><code>Tasmanian.getGPUMemory</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">getGPUMemory(tsg::TasmanianSG, GPUID)</code></pre><p>returns the total memory (in MegaBytes, 1024**2 bytes) of the corresponding GPU</p><p>this is one of several functions designed to allow basic management of multi-gpu setup with only Tasmanian module</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DynareJulia/Tasmanian.jl/blob/63629550ff87f2b47fd4d648d1d3ec81be894d7a/src/TSG.jl#L1891-L1899">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Tasmanian.getGPUName-Tuple{TasmanianSG, Any}" href="#Tasmanian.getGPUName-Tuple{TasmanianSG, Any}"><code>Tasmanian.getGPUName</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">getGPUName(tsg::TasmanianSG, GPUID)</code></pre><p>return the cuda name ID of the corresponding GPU</p><p>this is one of several functions designed to allow basic management of multi-gpu setup with only Tasmanian module</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DynareJulia/Tasmanian.jl/blob/63629550ff87f2b47fd4d648d1d3ec81be894d7a/src/TSG.jl#L1907-L1914">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Tasmanian.getGlobalPolynomialSpace-Tuple{TasmanianSG, Any}" href="#Tasmanian.getGlobalPolynomialSpace-Tuple{TasmanianSG, Any}"><code>Tasmanian.getGlobalPolynomialSpace</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">getGlobalPolynomialSpace(tsg::TasmanianSG, interpolation)</code></pre><p>returns a matrix corresponding to the polynomial space that is integrated or interpolated exactly by the current grid</p><p>interpolation: boolean         indicates whether to give the space associated         with integration or interpolation</p><p>output: is a matrix of integers         size(output, 1) is equal to iDimension         size(output, 2) indicates the cardinality of the space         each columns corresponds to a multi-index associated with a         polynomial in a hierarchical tensor basis, for example,         monomials</p><pre><code class="nohighlight hljs">    see the manual for details</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DynareJulia/Tasmanian.jl/blob/63629550ff87f2b47fd4d648d1d3ec81be894d7a/src/TSG.jl#L1737-L1755">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Tasmanian.getHierarchicalCoefficients-Tuple{TasmanianSG}" href="#Tasmanian.getHierarchicalCoefficients-Tuple{TasmanianSG}"><code>Tasmanian.getHierarchicalCoefficients</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">getHierarchicalCoefficients(tsg::TasmanianSG)</code></pre><p>For global grids, this just returns the values loaded using the call to loadNeededPoints(). In all other cases, this returns the list of hierarchical coefficients, i.e., surpluses.</p><p>returns a matrix getNumOutputs() by getNumPoints()</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DynareJulia/Tasmanian.jl/blob/63629550ff87f2b47fd4d648d1d3ec81be894d7a/src/TSG.jl#L1530-L1539">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Tasmanian.getHierarchicalSupport-Tuple{TasmanianSG}" href="#Tasmanian.getHierarchicalSupport-Tuple{TasmanianSG}"><code>Tasmanian.getHierarchicalSupport</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">getHierarchicalSupport(tsg::TasmanianSG)</code></pre><p>returns the support of the hierarchical basis in a matrix</p><ul><li>only local-polynomial and wavelet grids have restricted support</li><li>the support of all basis is restricted to the domain even if the support includes additional ares</li></ul><p>output: a matrix of dimensions getNumDimensions() by getNumPoints()         the support entries correspond to the output of getPoints()         if x represents a point in the domain and         if abs( x[j] - getPoints()[j, i] ) &gt; getSupport()[j, i]         then the i-th entry in evaluateHierarchicalFunctions(x)         corresponding to x is guaranteed to be zero</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DynareJulia/Tasmanian.jl/blob/63629550ff87f2b47fd4d648d1d3ec81be894d7a/src/TSG.jl#L1592-L1607">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Tasmanian.getInterpolationWeights-Tuple{Any, Any}" href="#Tasmanian.getInterpolationWeights-Tuple{Any, Any}"><code>Tasmanian.getInterpolationWeights</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">getInterpolationWeights(tsg, x)</code></pre><p>returns the interpolation weights associated with the points in getPoints()</p><p>x: a vector with length dimensions    the entries indicate the points for evaluating the weights</p><p>output: a vector of length getNumPoints()         the order of the weights matches the order in getPoints()</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DynareJulia/Tasmanian.jl/blob/63629550ff87f2b47fd4d648d1d3ec81be894d7a/src/TSG.jl#L682-L693">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Tasmanian.getInterpolationWeightsBatch-Tuple{Any, Any}" href="#Tasmanian.getInterpolationWeightsBatch-Tuple{Any, Any}"><code>Tasmanian.getInterpolationWeightsBatch</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">getInterpolationWeightsBatch(tsg, llfX):</code></pre><p>returns the interpolation weights associated with the points in getPoints()</p><p>finds multiple weights with a single library call uses OpenMP if enabled in libtasmaniansparsegrids.so</p><p>x: a matrix with first dimension getNumDimensions()    each column in the array is a single requested point</p><p>output: a matrix         with dimensions getNumPoints() X size(llfX, 2)           each row corresponds to the weight for one row of llfX</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DynareJulia/Tasmanian.jl/blob/63629550ff87f2b47fd4d648d1d3ec81be894d7a/src/TSG.jl#L707-L721">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Tasmanian.getLevelLimits-Tuple{TasmanianSG}" href="#Tasmanian.getLevelLimits-Tuple{TasmanianSG}"><code>Tasmanian.getLevelLimits</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">getLevelLimits(tsg::TasmanianSG)</code></pre><p>returns the limits set by the last call to make***Grid or refine returns a vector of integers corresponding to the limits for each direction, -1 indicates no limit</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DynareJulia/Tasmanian.jl/blob/63629550ff87f2b47fd4d648d1d3ec81be894d7a/src/TSG.jl#L1191-L1197">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Tasmanian.getLicense-Tuple{}" href="#Tasmanian.getLicense-Tuple{}"><code>Tasmanian.getLicense</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">getLicense()</code></pre><p>returns Tasmanian library hardcoded license string</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DynareJulia/Tasmanian.jl/blob/63629550ff87f2b47fd4d648d1d3ec81be894d7a/src/TSG.jl#L29-L33">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Tasmanian.getLoadedPoints-Tuple{TasmanianSG}" href="#Tasmanian.getLoadedPoints-Tuple{TasmanianSG}"><code>Tasmanian.getLoadedPoints</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">getLoadedPoints(tsg::TasmanianSG)</code></pre><p>returns the points loaded in the existing interpolant</p><p>output: matrix of size getNumDimensions() X getNumNeeded()     each column  corresponds to one point     if getNumLoaded() == 0, returns zeros(2)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DynareJulia/Tasmanian.jl/blob/63629550ff87f2b47fd4d648d1d3ec81be894d7a/src/TSG.jl#L604-L612">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Tasmanian.getLoadedValues-Tuple{TasmanianSG}" href="#Tasmanian.getLoadedValues-Tuple{TasmanianSG}"><code>Tasmanian.getLoadedValues</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">getLoadedValues(tsg::TasmanianSG)</code></pre><p>Returns the model values as given to Tasmanian by the loadNeededPoints() method. The ordering will match the current internal ordering, e.g., mixing the different model values from different refinement iterations.</p><p>Returns a matrix with size getNumOutputs() by getNumPoints()</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DynareJulia/Tasmanian.jl/blob/63629550ff87f2b47fd4d648d1d3ec81be894d7a/src/TSG.jl#L791-L798">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Tasmanian.getNeededPoints-Tuple{TasmanianSG}" href="#Tasmanian.getNeededPoints-Tuple{TasmanianSG}"><code>Tasmanian.getNeededPoints</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">getNeededPoints(tsg::TasmanianSG)</code></pre><p>returns the points needed to form the interpolant or the next level of refinement following a set***Refinement() call</p><p>output: 2-D array of size dimension X getNumNeeded()     each column  corresponds to one point     if (getNumNeeded() == 0): returns zeros(dimensions, 0)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DynareJulia/Tasmanian.jl/blob/63629550ff87f2b47fd4d648d1d3ec81be894d7a/src/TSG.jl#L625-L634">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Tasmanian.getNumDimensions-Tuple{TasmanianSG}" href="#Tasmanian.getNumDimensions-Tuple{TasmanianSG}"><code>Tasmanian.getNumDimensions</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">getNumDimensions(tsg::TasmanianSG)</code></pre><p>returns the value of iDimension in the make***Grid command if no grid has been made, it returns 0</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DynareJulia/Tasmanian.jl/blob/63629550ff87f2b47fd4d648d1d3ec81be894d7a/src/TSG.jl#L550-L555">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Tasmanian.getNumGPUs-Tuple{}" href="#Tasmanian.getNumGPUs-Tuple{}"><code>Tasmanian.getNumGPUs</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">getNumGPUs()
    returns the number of available GPUs according to cuda

    this is one of several functions designed to allow basic
    management of multi-gpu setup with only Tasmanian module</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DynareJulia/Tasmanian.jl/blob/63629550ff87f2b47fd4d648d1d3ec81be894d7a/src/TSG.jl#L1882-L1888">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Tasmanian.getNumLoaded-Tuple{TasmanianSG}" href="#Tasmanian.getNumLoaded-Tuple{TasmanianSG}"><code>Tasmanian.getNumLoaded</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">getNumLoaded(tsg::TasmanianSG)</code></pre><p>returns the number of points loaded in the existing interpolant</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DynareJulia/Tasmanian.jl/blob/63629550ff87f2b47fd4d648d1d3ec81be894d7a/src/TSG.jl#L581-L585">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Tasmanian.getNumNeeded-Tuple{TasmanianSG}" href="#Tasmanian.getNumNeeded-Tuple{TasmanianSG}"><code>Tasmanian.getNumNeeded</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">getNumNeeded(tsg::TasmanianSG)</code></pre><p>returns the number of points needed to form the interpolant or         form the next interpolant following a refinement</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DynareJulia/Tasmanian.jl/blob/63629550ff87f2b47fd4d648d1d3ec81be894d7a/src/TSG.jl#L588-L593">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Tasmanian.getNumOutputs-Tuple{TasmanianSG}" href="#Tasmanian.getNumOutputs-Tuple{TasmanianSG}"><code>Tasmanian.getNumOutputs</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">getNumOutputs(tsg::TasmanianSG)</code></pre><p>returns the value of iOutputs in the make***Grid command if no grid has been made, it returns 0</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DynareJulia/Tasmanian.jl/blob/63629550ff87f2b47fd4d648d1d3ec81be894d7a/src/TSG.jl#L558-L563">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Tasmanian.getNumPoints-Tuple{TasmanianSG}" href="#Tasmanian.getNumPoints-Tuple{TasmanianSG}"><code>Tasmanian.getNumPoints</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">getNumPoints(tsg::TasmanianSG)</code></pre><p>if points have been loaded, returns the same as getNumLoaded() otherwise, returns the same as getNumNeeded()</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DynareJulia/Tasmanian.jl/blob/63629550ff87f2b47fd4d648d1d3ec81be894d7a/src/TSG.jl#L596-L601">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Tasmanian.getOrder-Tuple{TasmanianSG}" href="#Tasmanian.getOrder-Tuple{TasmanianSG}"><code>Tasmanian.getOrder</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">getOrder(tsg::TasmanianSG)</code></pre><p>returns the value of iOrder in the call to makeLocalPolynomialGrid or makeWaveletGrid if makeLocalPolynomialGrid and makeWaveletGrid have not been called, returns -1</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DynareJulia/Tasmanian.jl/blob/63629550ff87f2b47fd4d648d1d3ec81be894d7a/src/TSG.jl#L540-L547">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Tasmanian.getPoints-Tuple{TasmanianSG}" href="#Tasmanian.getPoints-Tuple{TasmanianSG}"><code>Tasmanian.getPoints</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">getPoints(tsg::TasmanianSG)</code></pre><p>if points have been loaded, gives the same as getLoadedPoints() otherwise, returns the same as getNeededPoints()</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DynareJulia/Tasmanian.jl/blob/63629550ff87f2b47fd4d648d1d3ec81be894d7a/src/TSG.jl#L645-L650">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Tasmanian.getQuadratureWeights-Tuple{Any}" href="#Tasmanian.getQuadratureWeights-Tuple{Any}"><code>Tasmanian.getQuadratureWeights</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">getQuadratureWeights(tsg)</code></pre><p>returns the quadrature weights associated with the points in getPoints()</p><p>output: a vector of length getNumPoints()         the order of the weights matches         the order in getPoints()</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DynareJulia/Tasmanian.jl/blob/63629550ff87f2b47fd4d648d1d3ec81be894d7a/src/TSG.jl#L663-L672">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Tasmanian.getRule-Tuple{TasmanianSG}" href="#Tasmanian.getRule-Tuple{TasmanianSG}"><code>Tasmanian.getRule</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">getRule(tsg::TasmanianSG)</code></pre><p>returns the value of rule in the make***Grid command if makeWaveletGrid is used, returns &quot;wavelet&quot; if no grid has been made, it returns &quot;unknown&quot;</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DynareJulia/Tasmanian.jl/blob/63629550ff87f2b47fd4d648d1d3ec81be894d7a/src/TSG.jl#L566-L572">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Tasmanian.getSurplusRefinement" href="#Tasmanian.getSurplusRefinement"><code>Tasmanian.getSurplusRefinement</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">getSurplusRefinement(tsg::TasmanianSG, tolerance, output, criteria = &quot;&quot;, level_limits = Vector{Int32}(undef, 0), scale_correction = [])</code></pre><p>Calls setSurplusRefinement() on the inputs and then getNeededPoints().</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DynareJulia/Tasmanian.jl/blob/63629550ff87f2b47fd4d648d1d3ec81be894d7a/src/TSG.jl#L1408-L1412">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Tasmanian.getVersion-Tuple{}" href="#Tasmanian.getVersion-Tuple{}"><code>Tasmanian.getVersion</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">getVersion()</code></pre><p>returns Tasmanian library hardcoded version</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DynareJulia/Tasmanian.jl/blob/63629550ff87f2b47fd4d648d1d3ec81be894d7a/src/TSG.jl#L23-L27">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Tasmanian.get_VersionMajor-Tuple{}" href="#Tasmanian.get_VersionMajor-Tuple{}"><code>Tasmanian.get_VersionMajor</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_VersionMajor()</code></pre><p>returns the hardcoded version major int</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DynareJulia/Tasmanian.jl/blob/63629550ff87f2b47fd4d648d1d3ec81be894d7a/src/TSG.jl#L36-L40">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Tasmanian.get_VersionMinor-Tuple{}" href="#Tasmanian.get_VersionMinor-Tuple{}"><code>Tasmanian.get_VersionMinor</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_VersionMinor()</code></pre><p>returns the hardcoded version minor int</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DynareJulia/Tasmanian.jl/blob/63629550ff87f2b47fd4d648d1d3ec81be894d7a/src/TSG.jl#L43-L47">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Tasmanian.integrate-Tuple{TasmanianSG}" href="#Tasmanian.integrate-Tuple{TasmanianSG}"><code>Tasmanian.integrate</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">integrate(tsg::TasmanianSG)</code></pre><p>returns the integral of the interpolant</p><p>output: returns a vector of length outputs         the integral of the interpolant</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DynareJulia/Tasmanian.jl/blob/63629550ff87f2b47fd4d648d1d3ec81be894d7a/src/TSG.jl#L956-L963">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Tasmanian.integrateHierarchicalFunctions-Tuple{TasmanianSG}" href="#Tasmanian.integrateHierarchicalFunctions-Tuple{TasmanianSG}"><code>Tasmanian.integrateHierarchicalFunctions</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">integrateHierarchicalFunctions(tsg::TasmanianSG)</code></pre><p>Computes the integrals of the hierarchical basis functions, i.e., the same functions computed by evaluateHierarchicalFunctions().</p><p>returns a vector of length getNumPoints()</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DynareJulia/Tasmanian.jl/blob/63629550ff87f2b47fd4d648d1d3ec81be894d7a/src/TSG.jl#L1718-L1725">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Tasmanian.isAccelerationAvailable-Tuple{TasmanianSG, Any}" href="#Tasmanian.isAccelerationAvailable-Tuple{TasmanianSG, Any}"><code>Tasmanian.isAccelerationAvailable</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">isAccelerationAvailable(tsg::TasmanianSG, acceleration_type)</code></pre><p>returns true if the library has been compiled with support for acceleration_type. Even if this returns false, you can use the type for enableAcceleration, but the library will default to the next available type (see the Manual)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DynareJulia/Tasmanian.jl/blob/63629550ff87f2b47fd4d648d1d3ec81be894d7a/src/TSG.jl#L1833-L1841">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Tasmanian.isCudaEnabled-Tuple{}" href="#Tasmanian.isCudaEnabled-Tuple{}"><code>Tasmanian.isCudaEnabled</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">isCudaEnabled()</code></pre><p>returns <code>true</code> if the library has been computed with Cuda support</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DynareJulia/Tasmanian.jl/blob/63629550ff87f2b47fd4d648d1d3ec81be894d7a/src/TSG.jl#L57-L61">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Tasmanian.isDpcppEnabled-Tuple{}" href="#Tasmanian.isDpcppEnabled-Tuple{}"><code>Tasmanian.isDpcppEnabled</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">isDpcppEnabled()</code></pre><p>returns <code>true</code> if the library has been computed with DPC++ support</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DynareJulia/Tasmanian.jl/blob/63629550ff87f2b47fd4d648d1d3ec81be894d7a/src/TSG.jl#L71-L75">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Tasmanian.isFourier-Tuple{TasmanianSG}" href="#Tasmanian.isFourier-Tuple{TasmanianSG}"><code>Tasmanian.isFourier</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">isFourier(tsg::TasmanianSG)</code></pre><p>returns true if using a Fourier grid</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DynareJulia/Tasmanian.jl/blob/63629550ff87f2b47fd4d648d1d3ec81be894d7a/src/TSG.jl#L1050-L1054">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Tasmanian.isGlobal-Tuple{TasmanianSG}" href="#Tasmanian.isGlobal-Tuple{TasmanianSG}"><code>Tasmanian.isGlobal</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">isGlobal(tsg::TasmanianSG)</code></pre><p>returns true if using a global grid</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DynareJulia/Tasmanian.jl/blob/63629550ff87f2b47fd4d648d1d3ec81be894d7a/src/TSG.jl#L1023-L1027">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Tasmanian.isHipEnabled-Tuple{}" href="#Tasmanian.isHipEnabled-Tuple{}"><code>Tasmanian.isHipEnabled</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">isHipEnabled()</code></pre><p>returns <code>true</code> if the library has been computed with HIP support</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DynareJulia/Tasmanian.jl/blob/63629550ff87f2b47fd4d648d1d3ec81be894d7a/src/TSG.jl#L64-L68">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Tasmanian.isLocalPolynomial-Tuple{TasmanianSG}" href="#Tasmanian.isLocalPolynomial-Tuple{TasmanianSG}"><code>Tasmanian.isLocalPolynomial</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">isLocalPolynomial(tsg::TasmanianSG)</code></pre><p>returns true if using a local polynomial grid</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DynareJulia/Tasmanian.jl/blob/63629550ff87f2b47fd4d648d1d3ec81be894d7a/src/TSG.jl#L1037-L1041">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Tasmanian.isOpenMPEnabled-Tuple{}" href="#Tasmanian.isOpenMPEnabled-Tuple{}"><code>Tasmanian.isOpenMPEnabled</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">isOpenMPEnabled()</code></pre><p>returns <code>true</code> if the library has been computed with OpenMP support</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DynareJulia/Tasmanian.jl/blob/63629550ff87f2b47fd4d648d1d3ec81be894d7a/src/TSG.jl#L50-L54">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Tasmanian.isSequence-Tuple{TasmanianSG}" href="#Tasmanian.isSequence-Tuple{TasmanianSG}"><code>Tasmanian.isSequence</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">isSequence(tsg::TasmanianSG)</code></pre><p>returns true if using a sequence grid</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DynareJulia/Tasmanian.jl/blob/63629550ff87f2b47fd4d648d1d3ec81be894d7a/src/TSG.jl#L1030-L1034">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Tasmanian.isSetConformalTransformASIN-Tuple{TasmanianSG}" href="#Tasmanian.isSetConformalTransformASIN-Tuple{TasmanianSG}"><code>Tasmanian.isSetConformalTransformASIN</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">isSetConformalTransformASIN(tsg::TasmanianSG)</code></pre><p>returns true if conformal transform is set returns false otherwise</p><p>see: setConformalTransformASIN()</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DynareJulia/Tasmanian.jl/blob/63629550ff87f2b47fd4d648d1d3ec81be894d7a/src/TSG.jl#L1147-L1154">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Tasmanian.isSetDomainTransform-Tuple{TasmanianSG}" href="#Tasmanian.isSetDomainTransform-Tuple{TasmanianSG}"><code>Tasmanian.isSetDomainTransform</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>isSetDomainTransform(tsg::TasmaninaSG) returns true if the grid is defined for non-canonical domain         returns false if using a canonical domain</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DynareJulia/Tasmanian.jl/blob/63629550ff87f2b47fd4d648d1d3ec81be894d7a/src/TSG.jl#L1092-L1097">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Tasmanian.isWavelet-Tuple{TasmanianSG}" href="#Tasmanian.isWavelet-Tuple{TasmanianSG}"><code>Tasmanian.isWavelet</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">isWavelet(tsg::TasmanianSG)</code></pre><p>returns true if using a local wavelet grid</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DynareJulia/Tasmanian.jl/blob/63629550ff87f2b47fd4d648d1d3ec81be894d7a/src/TSG.jl#L1044-L1047">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Tasmanian.loadNeededPoints!-Tuple{TasmanianSG, AbstractArray{Float64}}" href="#Tasmanian.loadNeededPoints!-Tuple{TasmanianSG, AbstractArray{Float64}}"><code>Tasmanian.loadNeededPoints!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">loadNeededPoints!(tsg::TasmanianSG, vals::Array{Float64})</code></pre><p>loads the values of the target function at the needed points if there are no needed points, this reset the currently loaded values</p><p>vals: an array with dimensions outputs X getNumNeeded()        each column corresponds to the values of the outputs at       the corresponding needed point. The order and leading       dimension must match the points obtained from       getNeededPoints()</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DynareJulia/Tasmanian.jl/blob/63629550ff87f2b47fd4d648d1d3ec81be894d7a/src/TSG.jl#L742-L754">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Tasmanian.loadNeededValues!-Tuple{TasmanianSG, Array{Float64}}" href="#Tasmanian.loadNeededValues!-Tuple{TasmanianSG, Array{Float64}}"><code>Tasmanian.loadNeededValues!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">loadNeededValues!(tsg::TasmanianSG, vals::Array{Float64})</code></pre><p>Alias of loadNeededPoints()</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DynareJulia/Tasmanian.jl/blob/63629550ff87f2b47fd4d648d1d3ec81be894d7a/src/TSG.jl#L784-L788">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Tasmanian.makeFourierGrid!-Tuple{TasmanianSG}" href="#Tasmanian.makeFourierGrid!-Tuple{TasmanianSG}"><code>Tasmanian.makeFourierGrid!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">makeFourierGrid!(tsg::TasmanianSG; type, anisotropic_weights=Vector{Int32}(undef, 0), level_limits=Vector{Int32}(undef, 0))</code></pre><p>creates a new sparse grid using a Fourier rule discards any existing grid held by this class</p><p>type: string identifying the tensor selection strategy       &#39;level&#39;     &#39;curved&#39;     &#39;hyperbolic&#39;     &#39;tensor&#39;       &#39;iptotal&#39;   &#39;ipcurved&#39;   &#39;iphyperbolic&#39;   &#39;iptensor&#39;       &#39;qptotal&#39;   &#39;qpcurved&#39;   &#39;qphyperbolic&#39;   &#39;qptensor&#39;</p><p>anisotropic_weights: list or array of weights                      length must be iDimension or 2*iDimension                      the first tsg.dimensions weights must be positive                      see the manual for details</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DynareJulia/Tasmanian.jl/blob/63629550ff87f2b47fd4d648d1d3ec81be894d7a/src/TSG.jl#L366-L381">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Tasmanian.makeGlobalGrid!-Tuple{TasmanianSG}" href="#Tasmanian.makeGlobalGrid!-Tuple{TasmanianSG}"><code>Tasmanian.makeGlobalGrid!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">makeGlobalGrid!(tsg::TasmanianSG; type, rule, anisotropic_weights=Vector{Int32}(undef, 0), alpha=0.0, beta=0.0, custom_filename=&quot;&quot;, level_limits=Vector{Int32}(undef, 0))</code></pre><p>creates a new sparse grid using a global polynomial rule discards any existing grid held by <code>tsg</code></p><p>type: string identifying the tensor selection strategy      <code>level</code>     <code>curved</code>     <code>hyperbolic</code>     <code>tensor</code>      <code>iptotal</code>   <code>ipcurved</code>   <code>iphyperbolic</code>   <code>iptensor</code>      <code>qptotal</code>   <code>qpcurved</code>   <code>qphyperbolic</code>   <code>qptensor</code></p><p>rule: string (defines the 1-D rule that induces the grid)</p><pre><code class="nohighlight hljs">   Interpolation rules

      Note: the quadrature induced by those rules is constructed
            by integrating the interpolant

      `clenshaw-curtis`    `clenshaw-curtis-zero`      `fejer2`
      `rleja`    `rleja-odd`  `rleja-double2`   `rleja-double4`
      `rleja-shifted`   `rleja-shifted-even`
      `max-lebesgue`    `max-lebesgue-odd`
      `min-lebesgue`    `min-lebesgue-odd`
      `leja`            `leja-odd`
      `min-delta`       `min-delta-odd`

      `chebyshev`       `chebyshev-odd`
        approximation using roots of Chebyshev polynomials
        non-nested case (in contrast to Clenshaw-Curtis nodes)

   Quadrature rules, the weights target exactness with respect
                     to the highest polynomial degree possible

       `gauss-legendre`  `gauss-legendre-odd`
        approximation using roots of polynomials orthogonal in
        measure Uniform

       `gauss-patterson`  (a.k.a. nested Gauss-Legendre)
        Note: the nodes and weights are hard-coded hence there
        is a limit on the highest possible depth

       `gauss-chebyshev1`  `gauss-chebyshev1-odd`
       `gauss-chebyshev2`  `gauss-chebyshev2-odd`
         approximation using roots of polynomials orthogonal in
         measures  1/sqrt(1-x^2) and sqrt(1-x^2)  (respectively)

      `gauss-gegenbauer`  `gauss-gegenbauer-odd`
        approximation using roots of polynomials orthogonal in
        measure (1-x^2)^alpha

      `gauss-jacobi`
        approximation using roots of polynomials orthogonal in
        measure (1-x)^alpha * (1+x)^beta

      `gauss-laguerre`
        approximation using roots of polynomials orthogonal in
        measure x^alpha * epx(-x)

      `gauss-hermite`  `gauss-hermite-odd`
        approximation using roots of polynomials orthogonal in
        measure |x|^alpha * epx(-x^2)</code></pre><p>anisotropic_weights: list or array of weights (Int)                      length must be dimension or 2*dimension                      the first dimension weights must be positive                      see the manual for details</p><p>alpha, beta: Float64       alpha : the alpha parameter for Gegenbauer, Jacobi,                Hermite and Laguerre rules       beta  : the beta parameter for Jacobi rules</p><p>custom_filename: string giving the path to the file with              custom-tabulated rule</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DynareJulia/Tasmanian.jl/blob/63629550ff87f2b47fd4d648d1d3ec81be894d7a/src/TSG.jl#L154-L228">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Tasmanian.makeLocalPolynomialGrid!-Tuple{TasmanianSG}" href="#Tasmanian.makeLocalPolynomialGrid!-Tuple{TasmanianSG}"><code>Tasmanian.makeLocalPolynomialGrid!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">makeLocalPolynomialGrid!(tsg::TasmanianSG; order=1, rule=&quot;localp&quot;, level_limits=Vector{Int32}(undef, 0))</code></pre><p>creates a new sparse grid using a local polynomial rule discards any existing grid held by TSG</p><p>order: int (must be -1 or bigger)         -1 indicates largest possible order          1 means linear, 2 means quadratic, etc.          0 means piece-wise constant, it has different hierarchy            then the other orders, most notably the 1D rule            triples the number of points per level (as opposed            to double for the other cases)</p><p>rule: string (defines the 1-D rule that induces the grid)       <code>localp</code> <code>localp-zero</code>  <code>semi-localp</code>  <code>localp-boundary</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DynareJulia/Tasmanian.jl/blob/63629550ff87f2b47fd4d648d1d3ec81be894d7a/src/TSG.jl#L296-L313">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Tasmanian.makeSequenceGrid!-Tuple{TasmanianSG}" href="#Tasmanian.makeSequenceGrid!-Tuple{TasmanianSG}"><code>Tasmanian.makeSequenceGrid!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">makeSequenceGrid!(tsg::TasmanianSG; type, rule, anisotropic_weights=Vector{Int32}(undef, 0), level_limits=Vector{Int32}(undef, 0))</code></pre><p>creates a new sparse grid using a sequence rule discards any existing grid held by this class</p><p>type: string identifying the tensor selection strategy       &#39;level&#39;     &#39;curved&#39;     &#39;hyperbolic&#39;     &#39;tensor&#39;       &#39;iptotal&#39;   &#39;ipcurved&#39;   &#39;iphyperbolic&#39;   &#39;iptensor&#39;       &#39;qptotal&#39;   &#39;qpcurved&#39;   &#39;qphyperbolic&#39;   &#39;qptensor&#39;</p><p>rule: string (defines the 1-D rule that induces the grid)       &#39;leja&#39;       &#39;rleja&#39;      &#39;rleja-shifted&#39;       &#39;max-lebesgue&#39;   &#39;min-lebesgue&#39;   &#39;min-delta&#39;</p><p>anisotropic_weights: list or array of weights                      length must be <code>tsg.dimensions</code> or <code>2*tsg.dimensions</code>                      the first <code>tsg.dimensions</code> weights must be positive                      see the manual for details</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DynareJulia/Tasmanian.jl/blob/63629550ff87f2b47fd4d648d1d3ec81be894d7a/src/TSG.jl#L252-L271">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Tasmanian.makeWaveletGrid!-Tuple{Any}" href="#Tasmanian.makeWaveletGrid!-Tuple{Any}"><code>Tasmanian.makeWaveletGrid!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">makeWaveletGrid!(tsg::TasmanianSG; order=1, level_limits=Vector{Int32}(undef, 0))</code></pre><p>creates a new sparse grid using a wavelet rule discards any existing grid held by <code>tsg</code></p><p>order: Int (must be 1 or 3)        only wavelets of order 1 and 3 are implemented</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DynareJulia/Tasmanian.jl/blob/63629550ff87f2b47fd4d648d1d3ec81be894d7a/src/TSG.jl#L336-L344">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Tasmanian.mergeRefinement-Tuple{TasmanianSG}" href="#Tasmanian.mergeRefinement-Tuple{TasmanianSG}"><code>Tasmanian.mergeRefinement</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">mergeRefinement(tsg::TasmanianSG)</code></pre><p>combines the loaded and needed points into a single grid it also invalidates any currently loaded values, i.e., the grid cannot be used for internal integration or interpolation until loadNeededPoints() or setHierarchicalCoefficients() is called (even if those have been called before)</p><p>if getNumNeeded() == 0, this call will have no effect</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DynareJulia/Tasmanian.jl/blob/63629550ff87f2b47fd4d648d1d3ec81be894d7a/src/TSG.jl#L1429-L1439">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Tasmanian.printStats-Tuple{TasmanianSG}" href="#Tasmanian.printStats-Tuple{TasmanianSG}"><code>Tasmanian.printStats</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">printStats(tsg::TasmanianSG)</code></pre><p>calls the library printStats() function, which displays basic information about this instance of the grid</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DynareJulia/Tasmanian.jl/blob/63629550ff87f2b47fd4d648d1d3ec81be894d7a/src/TSG.jl#L1926-L1931">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Tasmanian.removePointsByHierarchicalCoefficient!" href="#Tasmanian.removePointsByHierarchicalCoefficient!"><code>Tasmanian.removePointsByHierarchicalCoefficient!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">removePointsByHierarchicalCoefficient!(tsg::TasmanianSG, tolerance, output = -1, scale_correction = [], NumKeep = -1)</code></pre><p>removes any points in the grid with relative surplus that exceeds the tolerance or keeps the set number of points with largest surplus</p><p>tolerance: float (positive)            the relative surplus tolerance, i.e.,            we keep only for points associated with surplus            that exceeds the tolerance            if NumKeep is positive, then tolerance is ignored</p><p>output: int (indicates the output to use)         selects which output to consider         accept -1 to indicate all outputs</p><p>scale_correction: vector or matrix                   if output = -1 and getNumOutputs() &gt; 1,                   then using matrix with shape                   getNumOutputs() X getNumLoaded() with                   one weight per hierarchical coefficient                   if output &gt; -1, then using a vector with                   one weight per point</p><p>NumKeep: int (positive or equal to -1)          indicates the number of points to keep          if set to -1 then tolerance is used as a cutoff          if positive then the given number of points will be kept</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DynareJulia/Tasmanian.jl/blob/63629550ff87f2b47fd4d648d1d3ec81be894d7a/src/TSG.jl#L1442-L1471">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Tasmanian.setAnisotropicRefinement!" href="#Tasmanian.setAnisotropicRefinement!"><code>Tasmanian.setAnisotropicRefinement!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">setAnisotropicRefinement!(tsg::TasmanianSG, type, min_growth, output, level_limits = Vector{Int32}(undef, 0))</code></pre><p>estimates anisotropic coefficients from the current set of loaded points and updates the grid with the best points according to the estimate</p><p>type: string identifying the estimate to use (see the Manual)       recommended: &#39;iptotal&#39;   &#39;ipcurved&#39;</p><p>min_growth: int (positive)             minimum number of new points to include in the new grid</p><p>output: int (indicates the output to use) selects which output to use for refinement         sequence grids, using -1 indicates to use all outputs</p><p>level_limits: (if not empty) will be used to overwrite the currently set limits. The limits must be either empty               or have size getNumDimensions(); if empty, the current set of limits will be used.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DynareJulia/Tasmanian.jl/blob/63629550ff87f2b47fd4d648d1d3ec81be894d7a/src/TSG.jl#L1205-L1223">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Tasmanian.setConformalTransformASIN!-Tuple{TasmanianSG, Any}" href="#Tasmanian.setConformalTransformASIN!-Tuple{TasmanianSG, Any}"><code>Tasmanian.setConformalTransformASIN!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">setConformalTransformASIN!(tsg::TasmanianSG, truncation)</code></pre><p>sets conformal domain transform based on truncated Maclaurin series of arcsin()</p><p>truncation: a vector of non-negative integers             indicating the truncation order in each direction             0 indicates no transform applied to this direction</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DynareJulia/Tasmanian.jl/blob/63629550ff87f2b47fd4d648d1d3ec81be894d7a/src/TSG.jl#L1128-L1136">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Tasmanian.setDomainTransform!-Tuple{TasmanianSG, VecOrMat}" href="#Tasmanian.setDomainTransform!-Tuple{TasmanianSG, VecOrMat}"><code>Tasmanian.setDomainTransform!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">setDomainTransform!(tsg::TasmanianSG, Transform::VecOrMat)</code></pre><p>sets the lower and upper bound for each dimension</p><p>Note: gauss-laguerre and gauss-hermite rules are defined on       unbounded domain, in which case  this sets the       shift and scale parameters, consult the manual</p><p>Transform: a matrix of size dimension X 2            transform specifies the lower and upper bound            of the domain in each direction.</p><pre><code class="nohighlight hljs">       For gauss-laguerre and gauss-hermite grids, the
       transform gives the a and b parameters of the
       weights
        exp(-b (x - a))
        exp(-b (x - a)^2)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DynareJulia/Tasmanian.jl/blob/63629550ff87f2b47fd4d648d1d3ec81be894d7a/src/TSG.jl#L1057-L1075">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Tasmanian.setGPUID!-Tuple{TasmanianSG, Any}" href="#Tasmanian.setGPUID!-Tuple{TasmanianSG, Any}"><code>Tasmanian.setGPUID!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">setGPUID!(tsg::TasmanianSG, GPUID)</code></pre><p>when using cuda on a machine with multiple GPUs, this helps set the GPU for this grid NOTE: each instance of the sparse grids class holds a separate       instance of GPUID and different grids can be assigned to       different GPUs (on multi-gpu system) GPUID can be changed at any time, however, this will cause some of the internal cache to be invalidated and it may lead to extraneous data movement</p><p>calling read or make***Grid will reset the selected GPU</p><p>defaults to 0</p><p>this doesn&#39;t do anything unless enableAcceleration is called using a &quot;gpu-&quot; acceleration type</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DynareJulia/Tasmanian.jl/blob/63629550ff87f2b47fd4d648d1d3ec81be894d7a/src/TSG.jl#L1849-L1867">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Tasmanian.setHierarchicalCoefficients!-Tuple{TasmanianSG, Any}" href="#Tasmanian.setHierarchicalCoefficients!-Tuple{TasmanianSG, Any}"><code>Tasmanian.setHierarchicalCoefficients!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">setHierarchicalCoefficients!(tsg::TasmanianSG, coefficients)</code></pre><p>Local polynomial, Wavelet, and Sequence grids construct  approximation using hierarchical coefficients based on the  loaded values. This function does the opposite, the hierarchical  coefficients are loaded directly and the values are computed  based on the coefficients. The coefficients can be computed,  e.g., by solving least-squares or compressed sensing problem             min || A c - f ||  where A is a matrix returned by evaluateHierarchicalFunctions()  or evaluateSparseHierarchicalFunctions() for a set of points  x; f are the values of the target function at the x  points; and c is the vector with corresponding hierarchical  coefficients.</p><p>If there is a pending refinement, i.e., getNumLoaded() != 0 and  getNumNeeded() != 0, then the refinement is discarded (since it  was computed based on the old and now obsolete values)</p><p>coefficients: a matrix with dimensions getNumOutputs() by getNumPoints()                each column corresponds to the values of the                coefficients at the corresponding point.                The order and leading dimension must match the                points obtained form getPoints(), the same                order as the second dimension of                evaluateHierarchicalFunctions().                This matrix must be of type Matrix{ComplexF64} when                using a Fourier grid.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DynareJulia/Tasmanian.jl/blob/63629550ff87f2b47fd4d648d1d3ec81be894d7a/src/TSG.jl#L1664-L1693">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Tasmanian.setSurplusRefinement!-Tuple{TasmanianSG, Float64}" href="#Tasmanian.setSurplusRefinement!-Tuple{TasmanianSG, Float64}"><code>Tasmanian.setSurplusRefinement!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">setSurplusRefinement!(tsg::TasmanianSG, tol::Float64; output::Int=-1, refinement_type::AbstractString=&quot;&quot;, level_limits=Vector{Int32}(undef, 0), scale_correction = Vector{Float64}(undef, 0))</code></pre><p>using hierarchical surplusses as an error indicator, the surplus refinement adds points to the grid to improve accuracy</p><p>when using sequence grids: this algorithm corresponds to the                            greedy Knapsack problem</p><p>when using local polynomial or wavelet grids, this call                          corresponds to local spatial refinement</p><p>tolerance: float (non-negative)            the relative error tolerance, i.e.,            we refine only for points associated with surplus            that exceeds the tolerance</p><p>output: int (indicates the output to use)          selects which output to use for refinement          sequence and local polynomial grids accept -1 to          indicate all outputs</p><p>refinement_type: hierarchical and direction refinement strategy                  &#39;classic&#39;  &#39;parents&#39;   &#39;direction&#39;   &#39;fds&#39;   &#39;stable&#39;                  applicable only for Local Polynomial and Wavelet grids</p><p>scale<em>correction: matrix of non-negative numbers                   Instead of comparing the normalized surpluses to                   the tolerance, the scaled surplus will be used.                   The correction allows to manually guide the                   refinement process.                   The surplus of the j-th output of the i-th point                   will be scaled by scale</em>correction[i][j].                   scale<em>correction.shape[0] must be equal to                   getNumLoaded()                   If empty, the scale is assumed 1.0                   scale</em>correction.shape[1] must be equal to the                   number of outputs used in the process, which is                   equal to getNumOutputs() for output == -1,                   or 1 if output &gt; -1.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DynareJulia/Tasmanian.jl/blob/63629550ff87f2b47fd4d648d1d3ec81be894d7a/src/TSG.jl#L1315-L1355">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Tasmanian.updateFourierGrid!-Tuple{TasmanianSG, Any, Any}" href="#Tasmanian.updateFourierGrid!-Tuple{TasmanianSG, Any, Any}"><code>Tasmanian.updateFourierGrid!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">updateFourierGrid!(tsg::TasmanianSG, depth, type; anisotropic_weights=Vector{Int32}(undef, 0), level_limits=Vector{Int32}(undef, 0))</code></pre><p>adds the points defined by depth, type and anisotropy to the existing grid</p><p>basically, the same as calling makeFourierGrid() with rule,            of this grid and the new depth, type and            anisotropic_weights then adding the resulting points            to the current grid</p><p>inputs: see help(makeGlobalGrid)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DynareJulia/Tasmanian.jl/blob/63629550ff87f2b47fd4d648d1d3ec81be894d7a/src/TSG.jl#L491-L502">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Tasmanian.updateGlobalGrid!-Tuple{TasmanianSG, Any, Any}" href="#Tasmanian.updateGlobalGrid!-Tuple{TasmanianSG, Any, Any}"><code>Tasmanian.updateGlobalGrid!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>updateGlobalGrid!(tsg::TasmanianSG, depth, type; anisotropic<em>weights=Vector{Int32}(undef, 0), level</em>limits=Vector{Int32}(undef, 0)) adds the points defined by depth, type and anisotropy to the existing grid</p><p>basically, the same as calling makeGlobalGrid with rule,            alpha and beta of this grid and the new depth,            type and anisotropic_weights then adding the            resulting points to the current grid</p><p>inputs: see help(makeGlobalGrid)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DynareJulia/Tasmanian.jl/blob/63629550ff87f2b47fd4d648d1d3ec81be894d7a/src/TSG.jl#L431-L442">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Tasmanian.updateSequenceGrid!-Tuple{TasmanianSG, Any, Any}" href="#Tasmanian.updateSequenceGrid!-Tuple{TasmanianSG, Any, Any}"><code>Tasmanian.updateSequenceGrid!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">updateSequenceGrid!(tsg::TasmanianSG, depth, type; anisotropic_weights=Vector{Int32}(undef, 0), level_limits=Vector{Int32}(undef, 0))</code></pre><p>adds the points defined by depth, type and anisotropy to the existing grid</p><p>basically, the same as calling makeSequenceGrid() with rule,            of this grid and the new depth, type and            anisotropic_weights then adding the resulting points            to the current grid</p><p>inputs: see help(makeSequenceGrid)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DynareJulia/Tasmanian.jl/blob/63629550ff87f2b47fd4d648d1d3ec81be894d7a/src/TSG.jl#L461-L473">source</a></section></article></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.7.0 on <span class="colophon-date" title="Wednesday 9 October 2024 15:56">Wednesday 9 October 2024</span>. Using Julia version 1.11.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
